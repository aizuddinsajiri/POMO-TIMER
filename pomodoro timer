import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, Toplevel, Listbox, Button, END
import pygame
import os
import ctypes
import time
from datetime import datetime, timedelta
import threading
import winsound

LOG_DIR = "logs"  # Directory where logs are saved

# Class to track application usage
class UsageTracker(threading.Thread):
    def __init__(self):
        super().__init__()
        self.running = threading.Event()  # Event to control the running state
        self.last_log_entry = ""
        self.current_window = None
        self.new_report = []  # New data entries will be stored here
        self.log_by_app = {}  # Dictionary to store logs grouped by application
        self.excluded_app = "Pomodoro Timer"  # Exclude this app from being tracked

        # Ensure the log directory exists
        if not os.path.exists(LOG_DIR):
            os.makedirs(LOG_DIR)

        self.log_file = self.get_log_filename()  # Generate log file name

    def get_log_filename(self):
        """Generate log filename based on the current date."""
        today = datetime.now().strftime('%Y-%m-%d')
        return os.path.join(LOG_DIR, f"{today}_usage_log.txt")  # Log file path

    def run(self):
        last_window = None
        start_time = None

        with open(self.log_file, "a", encoding="utf-8") as file:
            self.running.set()  # Set the running event
            while self.running.is_set():
                active_window = self.get_active_window_title()  # Get the currently active window title
                current_time = datetime.now()

                # Exclude tracking the app itself
                if active_window != last_window and active_window != self.excluded_app:
                    if last_window is not None:
                        end_time = current_time
                        duration = end_time - start_time
                        formatted_duration = divmod(duration.total_seconds(), 60)
                        minutes = int(formatted_duration[0])
                        seconds = int(formatted_duration[1])

                        # Log entry with date
                        log_entry = (f"{end_time.strftime('%Y-%m-%d')} - {last_window} - Start: {start_time.strftime('%H:%M:%S')} | "
                                     f"End: {end_time.strftime('%H:%M:%S')} | Duration: {minutes} minutes {seconds} seconds")
                        
                        # Add to new report
                        self.new_report.append(log_entry)

                        # Group logs by app name
                        if last_window not in self.log_by_app:
                            self.log_by_app[last_window] = []
                        self.log_by_app[last_window].append(log_entry)

                        # Write to the file
                        file.write(log_entry + "\n")
                        file.flush()

                    last_window = active_window
                    start_time = current_time

                time.sleep(1)  # Shortened sleep time for better accuracy

    def get_active_window_title(self):
        """Get the title of the currently active window."""
        user32 = ctypes.WinDLL('user32')
        GetForegroundWindow = user32.GetForegroundWindow
        GetWindowTextW = user32.GetWindowTextW
        GetWindowTextLengthW = user32.GetWindowTextLengthW

        hwnd = GetForegroundWindow()
        length = GetWindowTextLengthW(hwnd)
        buffer = ctypes.create_unicode_buffer(length + 1)
        GetWindowTextW(hwnd, buffer, length + 1)
        return buffer.value

    def start_tracking(self):
        """Start tracking the active window."""
        self.current_window = self.get_active_window_title()
        self.running.set()
        self.start()  # Start the thread

    def stop_tracking(self):
        """Stop tracking the active window."""
        self.running.clear()
        self.join(timeout=5)  # Wait for the thread to finish

# Main application class
class PomodoroApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Pomodoro Timer")  # Set window title
        self.geometry("600x500")  # Set window size
        self.configure(bg="#fff5f5")  # Set background color

        pygame.mixer.init()  # Initialize the pygame mixer for music
        self.music_playing = True
        self.play_background_music("background_music.mp3")  # Play background music

        # Default timer settings
        self.default_focus_time = 25
        self.default_break_time = 5
        self.focus_time = self.default_focus_time
        self.break_time = self.default_break_time
        self.timer_running = False
        self.is_break = False
        self.current_alarm_id = None
        self.presets = {}
        self.alarms = {}
        self.events = {}

        # Initialize the usage tracker
        self.tracker = UsageTracker()
        self.tracker.start_tracking()  # Start tracking when the app starts

        self.protocol("WM_DELETE_WINDOW", self.on_closing)  # Handle window close event

        # Notebook for tabbed interface
        self.tab_control = ttk.Notebook(self)
        self.pomodoro_tab = ttk.Frame(self.tab_control)  # Pomodoro tab
        self.customize_tab = ttk.Frame(self.tab_control) # Customize tab
        self.preset_tab = ttk.Frame(self.tab_control) # preset tab
        self.alarm_tab = ttk.Frame(self.tab_control)  # alarm tab
        self.event_tab = ttk.Frame(self.tab_control)  # event tab
        self.usage_tracker_tab = ttk.Frame(self.tab_control)  # Usage Tracker tab
        self.tab_control.add(self.pomodoro_tab, text='Pomodoro')  # Add Pomodoro tab
        self.tab_control.add(self.customize_tab, text='Customize')  # Add Customize tab
        self.tab_control.add(self.usage_tracker_tab, text='Usage Tracker')  # Add Usage Tracker tab
        self.tab_control.pack(expand=1, fill="both")  # Pack the tabs

        # Create the content for each tab
        self.create_pomodoro_tab()  
        self.create_customize_tab()
        self.create_preset_tab()
        self.create_alarm_tab()
        self.create_event_tab()
        self.start_periodic_checks()
        self.create_usage_tracker_tab()

        # Frame for control buttons
        self.button_frame = tk.Frame(self, bg="#fff5f5")
        self.button_frame.pack(pady=10)

        # Button to mute/unmute music
        self.mute_button = tk.Button(self.button_frame, text="Mute", command=self.toggle_music, font=("Arial", 10),
                                     bg="#ff6b6b", fg="white", relief="flat", width=10)
        self.mute_button.pack(side="left", padx=5)

        #Exit Button
        self.exit_button = tk.Button(self.button_frame, text="Exit", command=self.quit, font=("Arial", 10),
                                     bg="#ff6b6b", fg="white", relief="flat", width=10)
        self.exit_button.pack(side="left", padx=5)

    # Pomodoro Tab
    def create_pomodoro_tab(self):
        # Timer display
        self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
                                    bg="#fff5f5", fg="#ff6b6b")
        self.timer_label.pack(pady=20)

        # Motivational quote display
        self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
                                    fg="#4a4a4a")
        self.quote_label.pack(pady=10)

        # Start/Stop button for the timer
        self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
                                           font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
        self.start_stop_button.pack(pady=20)
        self.reset_timer()  # Initialize timer display

    # Customize Tab
    def create_customize_tab(self):
        self.default_var = tk.BooleanVar(value=True)  # Variable to track default/custom settings

        # Checkbox to use default timings
        self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
                                            variable=self.default_var, command=self.toggle_customization,
                                            font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
        self.default_check.pack(pady=10)

        # Frame for custom timing inputs
        self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
        self.custom_frame.pack()

        # Input for focus time
        self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
                                         bg="#fff5f5", fg="#4a4a4a")
        self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
        self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))  # Initially disabled
        self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)

        # Input for break time
        self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
                                          bg="#fff5f5", fg="#4a4a4a")
        self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
        self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))  # Initially disabled
        self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)

        # Button to save custom timings
        self.save_button = tk.Button(self.customize_tab, text="Save Custom Times", command=self.save_custom_times,
                                     font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat")
        self.save_button.pack(pady=10)

    def create_preset_tab(self):
        self.preset_frame = tk.Frame(self.preset_tab, bg="#fff5f5")
        self.preset_frame.pack(pady=10, padx=10, fill="x")

        self.task_name_label = tk.Label(self.preset_frame, text="Task Name:", font=("Arial", 12), bg="#fff5f5")
        self.task_name_label.grid(row=0, column=0, padx=5, pady=5)
        self.task_name_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
        self.task_name_entry.grid(row=0, column=1, padx=5, pady=5)

        self.preset_focus_label = tk.Label(self.preset_frame, text="Focus Time (minutes):", font=("Arial", 12), bg="#fff5f5")
        self.preset_focus_label.grid(row=1, column=0, padx=5, pady=5)
        self.preset_focus_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
        self.preset_focus_entry.grid(row=1, column=1, padx=5, pady=5)

        self.preset_break_label = tk.Label(self.preset_frame, text="Break Time (minutes):", font=("Arial", 12), bg="#fff5f5")
        self.preset_break_label.grid(row=2, column=0, padx=5, pady=5)
        self.preset_break_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
        self.preset_break_entry.grid(row=2, column=1, padx=5, pady=5)

        self.add_preset_button = tk.Button(self.preset_frame, text="Add Preset", command=self.add_preset,
                                          font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
        self.add_preset_button.grid(row=3, columnspan=2, pady=10)

        self.preset_listbox = tk.Listbox(self.preset_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
        self.preset_listbox.pack(pady=10, padx=10, fill="x")

        self.preset_listbox.bind('<<ListboxSelect>>', self.on_task_select)

        self.apply_preset_button = tk.Button(self.preset_tab, text="Apply Selected Preset", command=self.apply_preset,
                                             font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
        self.apply_preset_button.pack(pady=5)

        self.delete_preset_button = tk.Button(self.preset_tab, text="Delete Selected Preset",
                                              command=self.delete_preset,
                                              font=("Arial", 12), bg="#f44336", fg="white", width=20)
        self.delete_preset_button.pack(pady=5)

    def on_task_select(self, event):
        try:
            selected_task_index = self.preset_listbox.curselection()[0]
            self.selected_task = self.preset_listbox.get(selected_task_index)
        except IndexError:
            self.selected_task = None

    def create_alarm_tab(self):
        tk.Label(self.alarm_tab, text="Set Alarm", font=("Arial", 14), bg="#fff5f5").pack(pady=10)

        self.alarm_frame = tk.Frame(self.alarm_tab, bg="#fff5f5")
        self.alarm_frame.pack(pady=10)

        tk.Label(self.alarm_frame, text="Alarm Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0,
                                                                                                      padx=5, pady=5)
        self.alarm_time_entry = tk.Entry(self.alarm_frame, font=("Arial", 12))
        self.alarm_time_entry.grid(row=0, column=1, padx=5, pady=5)

        self.set_alarm_button = tk.Button(self.alarm_tab, text="Set Alarm", command=self.set_alarm,
                                          font=("Arial", 12), bg="#4caf50", fg="white", width=15)
        self.set_alarm_button.pack(pady=10)

        # Listbox for alarms
        self.alarm_listbox = tk.Listbox(self.alarm_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
        self.alarm_listbox.pack(pady=10, padx=10, fill="x")

        # Button to delete selected alarm
        self.delete_alarm_button = tk.Button(self.alarm_tab, text="Delete Selected Alarm", command=self.delete_alarm,
                                             font=("Arial", 12), bg="#f44336", fg="white", width=20)
        self.delete_alarm_button.pack(pady=5)

    def create_event_tab(self):
        tk.Label(self.event_tab, text="Set Event", font=("Arial", 14), bg="#fff5f5").pack(pady=10)

        self.event_frame = tk.Frame(self.event_tab, bg="#fff5f5")
        self.event_frame.pack(pady=10)

        tk.Label(self.event_frame, text="Event Name:", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0, padx=5,
                                                                                              pady=5)
        self.event_name_entry = tk.Entry(self.event_frame, font=("Arial", 12))
        self.event_name_entry.grid(row=0, column=1, padx=5, pady=5)
        tk.Label(self.event_frame, text="Start Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=1, column=0,
                                                                                                      padx=5, pady=5)
        self.event_start_entry = tk.Entry(self.event_frame, font=("Arial", 12))
        self.event_start_entry.grid(row=1, column=1, padx=5, pady=5)

        tk.Label(self.event_frame, text="End Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=2, column=0,
                                                                                                    padx=5, pady=5)
        self.event_end_entry = tk.Entry(self.event_frame, font=("Arial", 12))
        self.event_end_entry.grid(row=2, column=1, padx=5, pady=5)

        self.set_event_button = tk.Button(self.event_tab, text="Set Event", command=self.set_event,
                                          font=("Arial", 12), bg="#4caf50", fg="white", width=15)
        self.set_event_button.pack(pady=10)

        # Listbox for events
        self.event_listbox = tk.Listbox(self.event_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
        self.event_listbox.pack(pady=10, padx=10, fill="x")

        # Button to delete selected event
        self.delete_event_button = tk.Button(self.event_tab, text="Delete Selected Event", command=self.delete_event,
                                             font=("Arial", 12), bg="#f44336", fg="white", width=20)
        self.delete_event_button.pack(pady=5)

    def start_stop_timer(self):
        if not self.timer_running:
            self.timer_running = True
            self.start_stop_button.config(text="Stop")
            self.run_timer(self.focus_time * 60 * 1000)  # in milliseconds
        else:
            self.timer_running = False
            self.start_stop_button.config(text="Start")
            self.after_cancel(self.current_alarm_id)

    def reset_timer(self):
        self.timer_label.config(text=f"{self.focus_time:02}:00.00")
        self.quote_label.config(text="Time to focus")

    def run_timer(self, time_ms):
        if time_ms <= 0:
            self.timer_running = False
            self.reset_timer()
            if self.is_break:
                messagebox.showinfo("Break Time", "Break time is over!")
                winsound.Beep(1000, 1000)
                self.is_break = False
                self.start_stop_button.config(text="Start")
            else:
                messagebox.showinfo("Focus Time", "Focus time is over!")
                winsound.Beep(1000, 1000)
                self.is_break = True
                self.focus_time, self.break_time = self.break_time, self.focus_time
                self.timer_label.config(text=f"{self.focus_time:02}:00.00")
                self.start_stop_button.config(text="Start")
        else:
            mins, ms = divmod(time_ms, 60000)
            secs, ms = divmod(ms, 1000)
            self.timer_label.config(text=f"{mins:02}:{secs:02}.{ms // 10:02}")
            self.current_alarm_id = self.after(10, lambda: self.run_timer(time_ms - 10))

    def save_custom_times(self):
        if self.default_var.get():
            self.focus_time = self.default_focus_time
            self.break_time = self.default_break_time
        else:
            try:
                self.focus_time = int(self.long_break_entry.get())
                self.break_time = int(self.short_break_entry.get())
            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter valid integer values.")
                return
        self.reset_timer()

    def toggle_customization(self):
        if self.default_var.get():
            self.long_break_entry.config(state="disabled")
            self.short_break_entry.config(state="disabled")
        else:
            self.long_break_entry.config(state="normal")
            self.short_break_entry.config(state="normal")

    def add_preset(self):
        name = self.task_name_entry.get()
        try:
            focus = int(self.preset_focus_entry.get())
            break_time = int(self.preset_break_entry.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter valid integer values.")
            return

        if name in self.presets:
            messagebox.showerror("Preset Exists", "Preset with this name already exists.")
            return

        self.presets[name] = (focus, break_time)
        self.preset_listbox.insert(tk.END, name)

    def apply_preset(self):
        selected_task = self.preset_listbox.get(tk.ACTIVE)
        if selected_task in self.presets:
            self.focus_time, self.break_time = self.presets[selected_task]
            self.reset_timer()

    def delete_preset(self):
        selected_task = self.preset_listbox.get(tk.ACTIVE)
        if selected_task in self.presets:
            del self.presets[selected_task]
            self.preset_listbox.delete(tk.ACTIVE)

    def set_alarm(self):
        alarm_time_str = self.alarm_time_entry.get()
        try:
            alarm_time = datetime.strptime(alarm_time_str, "%H:%M").time()
        except ValueError:
            messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
            return

        alarm_datetime = datetime.combine(datetime.today(), alarm_time)
        if alarm_datetime < datetime.now():
            alarm_datetime += timedelta(days=1)

        self.alarms[alarm_datetime] = alarm_time
        self.update_alarm_listbox()  # Update listbox

    def set_event(self):
        event_name = self.event_name_entry.get()
        try:
            start_time_str = self.event_start_entry.get()
            end_time_str = self.event_end_entry.get()
            start_time = datetime.strptime(start_time_str, "%H:%M").time()
            end_time = datetime.strptime(end_time_str, "%H:%M").time()
        except ValueError:
            messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
            return

        start_datetime = datetime.combine(datetime.today(), start_time)
        end_datetime = datetime.combine(datetime.today(), end_time)
        if end_datetime < start_datetime:
            end_datetime += timedelta(days=1)

        if start_datetime < datetime.now():
            start_datetime += timedelta(days=1)
        if end_datetime < datetime.now():
            end_datetime += timedelta(days=1)

        self.events[event_name] = (start_datetime, end_datetime)
        self.update_event_listbox()  # Update listbox

    def update_alarm_listbox(self):
        self.alarm_listbox.delete(0, tk.END)
        for alarm_time in sorted(self.alarms.keys()):
            self.alarm_listbox.insert(tk.END, alarm_time.strftime("%H:%M"))

    def update_event_listbox(self):
        self.event_listbox.delete(0, tk.END)
        for event_name in self.events.keys():
            start_time, end_time = self.events[event_name]
            self.event_listbox.insert(tk.END,
                                      f"{event_name}: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}")

    def delete_alarm(self):
        selected_alarm_index = self.alarm_listbox.curselection()
        if selected_alarm_index:
            selected_alarm_time_str = self.alarm_listbox.get(selected_alarm_index[0])
            selected_alarm_time = datetime.strptime(selected_alarm_time_str, "%H:%M").time()
            alarm_datetime = datetime.combine(datetime.today(), selected_alarm_time)
            if alarm_datetime in self.alarms:
                del self.alarms[alarm_datetime]
                self.update_alarm_listbox()  # Update listbox

    def delete_event(self):
        selected_event_index = self.event_listbox.curselection()
        if selected_event_index:
            selected_event_info = self.event_listbox.get(selected_event_index[0])
            event_name = selected_event_info.split(":")[0]
            if event_name in self.events:
                del self.events[event_name]
                self.update_event_listbox()  # Update listbox

    def check_alarms(self):
        current_time = datetime.now()
        alarms_to_remove = []
        for alarm_time in sorted(self.alarms.keys()):
            if alarm_time <= current_time:
                messagebox.showinfo("Alarm", "Alarm time reached!")
                winsound.Beep(1000, 1000)
                alarms_to_remove.append(alarm_time)
        for alarm_time in alarms_to_remove:
            del self.alarms[alarm_time]

    def check_events(self):
        current_time = datetime.now()
        events_to_remove = []
        for event_name, (start_datetime, end_datetime) in sorted(self.events.items()):
            if start_datetime <= current_time <= end_datetime:
                messagebox.showinfo("Event", f"{event_name} is starting!")
                winsound.Beep(1000, 1000)
                events_to_remove.append(event_name)
        for event_name in events_to_remove:
            del self.events[event_name]

    def start_periodic_checks(self):
        self.check_alarms()
        self.check_events()
        self.after(1000, self.start_periodic_checks)  # Schedule the next check in 1 second

    # Usage Tracker Tab
    def create_usage_tracker_tab(self):
        # Button to show report
        self.show_report_button = tk.Button(self.usage_tracker_tab, text="Show Report", command=self.show_report,
                                             font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat")
        self.show_report_button.pack(pady=20)

        # Button to load log file
        self.load_log_button = tk.Button(self.usage_tracker_tab, text="Load Log File", command=self.open_log_selection_window,
                                          font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat")
        self.load_log_button.pack(pady=20)

    # Start/Stop Timer Functionality
    def start_stop_timer(self):
        if self.timer_running:
            self.stop_timer()
        else:
            self.start_timer()

    def start_timer(self):
        self.timer_running = True
        self.is_break = False
        self.start_stop_button.config(text="Stop")  # Change button text to "Stop"
        self.run_timer(self.focus_time * 60)  # Start timer for focus time

    def stop_timer(self):
        self.timer_running = False
        self.start_stop_button.config(text="Start")  # Change button text back to "Start"

    def run_timer(self, remaining_seconds):
        self.timer_label.config(text=f"{remaining_seconds // 60:02}:{remaining_seconds % 60:02}.00")
        if remaining_seconds > 0:
            self.after(1000, self.run_timer, remaining_seconds - 1)  # Call itself every second
        else:
            self.play_sound()  # Play sound when time is up
            if not self.is_break:  # Check if it's a break
                self.is_break = True
                self.quote_label.config(text="Time for a break!")  # Change quote
                self.run_timer(self.break_time * 60)  # Start break timer
            else:
                self.is_break = False
                self.quote_label.config(text="Time to focus!")  # Change quote
                self.reset_timer()  # Reset the timer

    def reset_timer(self):
        self.timer_label.config(text=f"{self.focus_time:02}:00.00")  # Reset timer display

    # Music Control
    def play_background_music(self, file):
        """Play background music."""
        try:
            pygame.mixer.music.load(file)
            pygame.mixer.music.play(-1)  # Loop indefinitely
        except pygame.error as e:
            messagebox.showerror("Error", f"Could not play music: {e}")

    def toggle_music(self):
        """Toggle mute/unmute music."""
        if self.music_playing:
            pygame.mixer.music.pause()  # Pause music
            self.mute_button.config(text="Unmute")  # Update button text
        else:
            pygame.mixer.music.unpause()  # Unpause music
            self.mute_button.config(text="Mute")  # Update button text
        self.music_playing = not self.music_playing  # Toggle state

    # Customization Functions
    def toggle_customization(self):
        """Toggle between default and custom timer settings."""
        if self.default_var.get():  # If using default timings
            self.long_break_entry.config(state="disabled")  # Disable focus time input
            self.short_break_entry.config(state="disabled")  # Disable break time input
            self.focus_time = self.default_focus_time  # Reset to default focus time
            self.break_time = self.default_break_time  # Reset to default break time
            self.reset_timer()  # Reset timer display
        else:  # If using custom timings
            self.long_break_entry.config(state="normal")  # Enable focus time input
            self.short_break_entry.config(state="normal")  # Enable break time input

    def save_custom_times(self):
        """Save custom focus and break times."""
        try:
            focus_time = int(self.long_break_entry.get())  # Get custom focus time
            break_time = int(self.short_break_entry.get())  # Get custom break time
            if focus_time <= 0 or break_time <= 0:
                raise ValueError  # Raise error if values are invalid

            self.focus_time = focus_time  # Update focus time
            self.break_time = break_time  # Update break time
            messagebox.showinfo("Success", "Custom times saved successfully!")  # Success message
            self.reset_timer()  # Reset timer display
        except ValueError:
            messagebox.showerror("Error", "Please enter valid positive integers.")  # Error message

    # Usage Tracking Functions
    def show_report(self):
        """Display the usage report in a new window."""
        report_window = Toplevel(self)
        report_window.title("Usage Report")
        report_window.geometry("400x300")
        
        # Create a scrollable text area
        report_text_area = scrolledtext.ScrolledText(report_window, width=50, height=15)
        report_text_area.pack(padx=10, pady=10)

        # Write report contents to text area
        report_text_area.insert(END, "\n".join(self.tracker.new_report) if self.tracker.new_report else "No usage data available.")
        report_text_area.config(state="disabled")  # Make it read-only

    def open_log_selection_window(self):
        """Open a window to select and load a log file."""
        log_window = Toplevel(self)
        log_window.title("Select Log File")
        log_window.geometry("300x400")
        
        listbox = Listbox(log_window)  # Listbox to display log files
        listbox.pack(padx=10, pady=10, fill="both", expand=True)

        # Load available log files into listbox
        for log_file in os.listdir(LOG_DIR):
            if log_file.endswith("_usage_log.txt"):
                listbox.insert(END, log_file)

        # Button to load the selected log file
        load_button = Button(log_window, text="Load Selected Log", command=lambda: self.load_selected_log(listbox, log_window))
        load_button.pack(pady=10)

    def load_selected_log(self, listbox, window):
        """Load and display the contents of the selected log file."""
        selected_file = listbox.get(listbox.curselection())
        full_path = os.path.join(LOG_DIR, selected_file)  # Get the full path to the log file

        with open(full_path, "r", encoding="utf-8") as file:
            log_contents = file.read()  # Read file contents

        # Show the log contents in a message box
        messagebox.showinfo("Log Contents", log_contents)
        window.destroy()  # Close the selection window

    def on_closing(self):
        """Handle closing the application."""
        self.tracker.stop_tracking()  # Stop tracking
        self.destroy()  # Destroy the application

# Main application entry point
if __name__ == "__main__":
    app = PomodoroApp()  # Create the application
    app.mainloop()  # Start the main loop
