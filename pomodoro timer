import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, Toplevel, Listbox, Button, END
import pygame
import os
import ctypes
import time
from datetime import datetime, timedelta
import threading
import winsound

LOG_DIR = "logs"  # Directory where logs are saved
class PomodoroApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("PomoTimer")
        self.geometry("600x500")
        self.configure(bg="#fff5f5")

        pygame.mixer.init()  # Initialize the pygame mixer for music
        self.music_playing = True
        self.play_background_music("background_music.mp3")

        self.default_focus_time = 25  # in minutes
        self.default_break_time = 5   # in minutes
        self.focus_time = self.default_focus_time
        self.break_time = self.default_break_time
        self.timer_running = False
        self.is_break = False
        self.current_alarm_id = None
        self.presets = {}
        self.alarms = {}
        self.events = {}

        self.tracker = UsageTracker()
        self.tracker.start_tracking()


        # Tabs
        self.tab_control = ttk.Notebook(self)
        self.pomodoro_tab = ttk.Frame(self.tab_control)
        self.customize_tab = ttk.Frame(self.tab_control)
        self.preset_tab = ttk.Frame(self.tab_control)
        self.alarm_tab = ttk.Frame(self.tab_control)
        self.event_tab = ttk.Frame(self.tab_control)
        self.usage_tracker_tab = ttk.Frame(self.tab_control)
        self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
        self.tab_control.add(self.customize_tab, text='Customize')
        self.tab_control.add(self.preset_tab, text='Preset')
        self.tab_control.add(self.alarm_tab, text='Alarm')
        self.tab_control.add(self.event_tab, text='Events')
        self.tab_control.add(self.usage_tracker_tab, text='Usage Tracker')
        self.tab_control.pack(expand=1, fill="both")

        self.create_pomodoro_tab()
        self.create_customize_tab()
        self.create_preset_tab()
        self.create_alarm_tab()
        self.create_event_tab()
        self.start_periodic_checks()
        self.create_usage_tracker_tab()

        self.button_frame = tk.Frame(self, bg="#fff5f5")
        self.button_frame.pack(pady=10)

        self.mute_button = tk.Button(self.button_frame, text="Mute", command=self.toggle_music, font=("Arial", 10),
                                     bg="#ff6b6b", fg="white", relief="flat", width=10)
        self.mute_button.pack(padx=5)

        # Exit Button
        self.exit_button = tk.Button(self, text="Exit", command=self.destroy, font=("Arial", 10), bg="#ff6b6b", fg="white",
                                     relief="flat", width=10)
        self.exit_button.pack(padx=5)

    def create_pomodoro_tab(self):
        self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
                                    bg="#fff5f5", fg="#ff6b6b")
        self.timer_label.pack(pady=20)

        self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
                                    fg="#4a4a4a")
        self.quote_label.pack(pady=10)

        # Preset name label will be dynamically updated later when a preset is applied
        self.preset_name_label = tk.Label(self.pomodoro_tab, text="Preset: None", font=("Arial", 12), bg="#fff5f5",
                                          fg="#4a4a4a")
        self.preset_name_label.pack(pady=5)

        self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
                                           font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
        self.start_stop_button.pack(pady=20)
        self.reset_timer()

    def create_customize_tab(self):
        self.default_var = tk.BooleanVar(value=True)

        self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
                                            variable=self.default_var, command=self.toggle_customization,
                                            font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
        self.default_check.pack(pady=20)

        self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
        self.custom_frame.pack()

        self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
                                         bg="#fff5f5", fg="#4a4a4a")
        self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
        self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
        self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)

        self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
                                          bg="#fff5f5", fg="#4a4a4a")
        self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
        self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
        self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)

        self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
                                     font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
        self.save_button.pack(pady=10)

    def create_preset_tab(self):
        self.preset_frame = tk.Frame(self.preset_tab, bg="#fff5f5")
        self.preset_frame.pack(pady=10, padx=10, fill="x")

        self.task_name_label = tk.Label(self.preset_frame, text="Task Name:", font=("Arial", 12), bg="#fff5f5")
        self.task_name_label.grid(row=0, column=0, padx=5, pady=5)
        self.task_name_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
        self.task_name_entry.grid(row=0, column=1, padx=5, pady=5)

        self.preset_focus_label = tk.Label(self.preset_frame, text="Focus Time (minutes):", font=("Arial", 12), bg="#fff5f5")
        self.preset_focus_label.grid(row=1, column=0, padx=5, pady=5)
        self.preset_focus_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
        self.preset_focus_entry.grid(row=1, column=1, padx=5, pady=5)

        self.preset_break_label = tk.Label(self.preset_frame, text="Break Time (minutes):", font=("Arial", 12), bg="#fff5f5")
        self.preset_break_label.grid(row=2, column=0, padx=5, pady=5)
        self.preset_break_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
        self.preset_break_entry.grid(row=2, column=1, padx=5, pady=5)

        self.add_preset_button = tk.Button(self.preset_frame, text="Add Preset", command=self.add_preset,
                                          font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
        self.add_preset_button.grid(row=3, columnspan=2, pady=10)

        self.preset_listbox = tk.Listbox(self.preset_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
        self.preset_listbox.pack(pady=10, padx=10, fill="x")

        self.preset_listbox.bind('<<ListboxSelect>>', self.on_task_select)

        self.apply_preset_button = tk.Button(self.preset_tab, text="Apply Selected Preset", command=self.apply_preset,
                                             font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
        self.apply_preset_button.pack(pady=5)

        self.delete_preset_button = tk.Button(self.preset_tab, text="Delete Selected Preset",
                                              command=self.delete_preset,
                                              font=("Arial", 12), bg="#f44336", fg="white", width=20)
        self.delete_preset_button.pack(pady=5)

    def on_task_select(self, event):
        try:
            selected_task_index = self.preset_listbox.curselection()[0]
            self.selected_task = self.preset_listbox.get(selected_task_index)
        except IndexError:
            self.selected_task = None

    def create_alarm_tab(self):
        tk.Label(self.alarm_tab, text="Set Alarm", font=("Arial", 14), bg="#fff5f5").pack(pady=10)

        self.alarm_frame = tk.Frame(self.alarm_tab, bg="#fff5f5")
        self.alarm_frame.pack(pady=10)

        tk.Label(self.alarm_frame, text="Alarm Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0,
                                                                                                      padx=5, pady=5)
        self.alarm_time_entry = tk.Entry(self.alarm_frame, font=("Arial", 12))
        self.alarm_time_entry.grid(row=0, column=1, padx=5, pady=5)

        self.set_alarm_button = tk.Button(self.alarm_tab, text="Set Alarm", command=self.set_alarm,
                                          font=("Arial", 12), bg="#4caf50", fg="white", width=15)
        self.set_alarm_button.pack(pady=10)

        # Listbox for alarms
        self.alarm_listbox = tk.Listbox(self.alarm_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
        self.alarm_listbox.pack(pady=10, padx=10, fill="x")

        # Button to delete selected alarm
        self.delete_alarm_button = tk.Button(self.alarm_tab, text="Delete Selected Alarm", command=self.delete_alarm,
                                             font=("Arial", 12), bg="#f44336", fg="white", width=20)
        self.delete_alarm_button.pack(pady=5)

    def create_event_tab(self):
        tk.Label(self.event_tab, text="Set Event", font=("Arial", 14), bg="#fff5f5").pack(pady=10)

        self.event_frame = tk.Frame(self.event_tab, bg="#fff5f5")
        self.event_frame.pack(pady=10)

        tk.Label(self.event_frame, text="Event Name:", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0, padx=5,
                                                                                              pady=5)
        self.event_name_entry = tk.Entry(self.event_frame, font=("Arial", 12))
        self.event_name_entry.grid(row=0, column=1, padx=5, pady=5)
        tk.Label(self.event_frame, text="Start Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=1, column=0,
                                                                                                      padx=5, pady=5)
        self.event_start_entry = tk.Entry(self.event_frame, font=("Arial", 12))
        self.event_start_entry.grid(row=1, column=1, padx=5, pady=5)

        tk.Label(self.event_frame, text="End Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=2, column=0,
                                                                                                    padx=5, pady=5)
        self.event_end_entry = tk.Entry(self.event_frame, font=("Arial", 12))
        self.event_end_entry.grid(row=2, column=1, padx=5, pady=5)

        self.set_event_button = tk.Button(self.event_tab, text="Set Event", command=self.set_event,
                                          font=("Arial", 12), bg="#4caf50", fg="white", width=15)
        self.set_event_button.pack(pady=10)

        # Listbox for events
        self.event_listbox = tk.Listbox(self.event_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
        self.event_listbox.pack(pady=10, padx=10, fill="x")

        # Button to delete selected event
        self.delete_event_button = tk.Button(self.event_tab, text="Delete Selected Event", command=self.delete_event,
                                             font=("Arial", 12), bg="#f44336", fg="white", width=20)
        self.delete_event_button.pack(pady=5)

    def start_stop_timer(self):
        if not self.timer_running:
            self.timer_running = True
            self.start_stop_button.config(text="Stop")
            self.run_timer(self.focus_time * 60 * 1000)  # in milliseconds
        else:
            self.timer_running = False
            self.start_stop_button.config(text="Start")
            self.after_cancel(self.current_alarm_id)

    def reset_timer(self):
        self.timer_label.config(text=f"{self.focus_time:02}:00.00")
        self.quote_label.config(text="Time to focus")

    def run_timer(self, time_ms):
        if time_ms <= 0:
            self.timer_running = False
            self.reset_timer()
            if self.is_break:
                messagebox.showinfo("Break Time", "Break time is over!")
                winsound.Beep(1000, 1000)
                self.is_break = False
                self.start_stop_button.config(text="Start")
            else:
                messagebox.showinfo("Focus Time", "Focus time is over!")
                winsound.Beep(1000, 1000)
                self.is_break = True
                self.focus_time, self.break_time = self.break_time, self.focus_time
                self.timer_label.config(text=f"{self.focus_time:02}:00.00")
                self.start_stop_button.config(text="Start")
        else:
            mins, ms = divmod(time_ms, 60000)
            secs, ms = divmod(ms, 1000)
            self.timer_label.config(text=f"{mins:02}:{secs:02}.{ms // 10:02}")
            self.current_alarm_id = self.after(10, lambda: self.run_timer(time_ms - 10))

    def save_custom_times(self):
        if self.default_var.get():
            self.focus_time = self.default_focus_time
            self.break_time = self.default_break_time
        else:
            try:
                self.focus_time = int(self.long_break_entry.get())
                self.break_time = int(self.short_break_entry.get())
            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter valid integer values.")
                return
        self.reset_timer()
        self.tab_control.select(self.pomodoro_tab)  # Return to Pomodoro tab after saving

    def toggle_customization(self):
        if self.default_var.get():
            self.long_break_entry.config(state="disabled")
            self.short_break_entry.config(state="disabled")
        else:
            self.long_break_entry.config(state="normal")
            self.short_break_entry.config(state="normal")

    def add_preset(self):
        name = self.task_name_entry.get()
        try:
            focus = int(self.preset_focus_entry.get())
            break_time = int(self.preset_break_entry.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter valid integer values.")
            return

        if name in self.presets:
            messagebox.showerror("Preset Exists", "Preset with this name already exists.")
            return

        self.presets[name] = (focus, break_time)
        self.preset_listbox.insert(tk.END, name)

    def apply_preset(self):
        selected_task = self.preset_listbox.get(tk.ACTIVE)
        if selected_task in self.presets:
            self.focus_time, self.break_time = self.presets[selected_task]
            self.selected_preset_name = selected_task  # Save selected preset name
            self.reset_timer()
            self.update_preset_label()  # Update the label on the Pomodoro timer
            self.tab_control.select(self.pomodoro_tab)  # Switch to the Pomodoro tab

    def update_preset_label(self):
        if hasattr(self, 'preset_name_label'):  # Check if the label already exists
            self.preset_name_label.config(text=f"Preset: {self.selected_preset_name}")
        else:
            self.preset_name_label = tk.Label(self.pomodoro_tab, text=f"Preset: {self.selected_preset_name}",
                                              font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
            self.preset_name_label.pack(pady=5)

    def delete_preset(self):
        selected_task = self.preset_listbox.get(tk.ACTIVE)
        if selected_task in self.presets:
            del self.presets[selected_task]
            self.preset_listbox.delete(tk.ACTIVE)

    def set_alarm(self):
        alarm_time_str = self.alarm_time_entry.get()
        try:
            alarm_time = datetime.strptime(alarm_time_str, "%H:%M").time()
        except ValueError:
            messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
            return

        alarm_datetime = datetime.combine(datetime.today(), alarm_time)
        if alarm_datetime < datetime.now():
            alarm_datetime += timedelta(days=1)

        self.alarms[alarm_datetime] = alarm_time
        self.update_alarm_listbox()  # Update listbox

    def set_event(self):
        event_name = self.event_name_entry.get()
        try:
            start_time_str = self.event_start_entry.get()
            end_time_str = self.event_end_entry.get()
            start_time = datetime.strptime(start_time_str, "%H:%M").time()
            end_time = datetime.strptime(end_time_str, "%H:%M").time()
        except ValueError:
            messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
            return

        start_datetime = datetime.combine(datetime.today(), start_time)
        end_datetime = datetime.combine(datetime.today(), end_time)
        if end_datetime < start_datetime:
            end_datetime += timedelta(days=1)

        if start_datetime < datetime.now():
            start_datetime += timedelta(days=1)
        if end_datetime < datetime.now():
            end_datetime += timedelta(days=1)

        self.events[event_name] = (start_datetime, end_datetime)
        self.update_event_listbox()  # Update listbox

    def update_alarm_listbox(self):
        self.alarm_listbox.delete(0, tk.END)
        for alarm_time in sorted(self.alarms.keys()):
            self.alarm_listbox.insert(tk.END, alarm_time.strftime("%H:%M"))

    def update_event_listbox(self):
        self.event_listbox.delete(0, tk.END)
        for event_name in self.events.keys():
            start_time, end_time = self.events[event_name]
            self.event_listbox.insert(tk.END,
                                      f"{event_name}: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}")

    def delete_alarm(self):
        selected_alarm_index = self.alarm_listbox.curselection()
        if selected_alarm_index:
            selected_alarm_time_str = self.alarm_listbox.get(selected_alarm_index[0])
            selected_alarm_time = datetime.strptime(selected_alarm_time_str, "%H:%M").time()
            alarm_datetime = datetime.combine(datetime.today(), selected_alarm_time)
            if alarm_datetime in self.alarms:
                del self.alarms[alarm_datetime]
                self.update_alarm_listbox()  # Update listbox

    def delete_event(self):
        selected_event_index = self.event_listbox.curselection()
        if selected_event_index:
            selected_event_info = self.event_listbox.get(selected_event_index[0])
            event_name = selected_event_info.split(":")[0]
            if event_name in self.events:
                del self.events[event_name]
                self.update_event_listbox()  # Update listbox

    def check_alarms(self):
        current_time = datetime.now()
        alarms_to_remove = []
        for alarm_time in sorted(self.alarms.keys()):
            if alarm_time <= current_time:
                messagebox.showinfo("Alarm", "Alarm time reached!")
                winsound.Beep(1000, 1000)
                alarms_to_remove.append(alarm_time)
        for alarm_time in alarms_to_remove:
            del self.alarms[alarm_time]

    def check_events(self):
        current_time = datetime.now()
        events_to_remove = []
        for event_name, (start_datetime, end_datetime) in sorted(self.events.items()):
            if start_datetime <= current_time <= end_datetime:
                messagebox.showinfo("Event", f"{event_name} is starting!")
                winsound.Beep(1000, 1000)
                events_to_remove.append(event_name)
        for event_name in events_to_remove:
            del self.events[event_name]

    def start_periodic_checks(self):
        self.check_alarms()
        self.check_events()
        self.after(1000, self.start_periodic_checks)  # Schedule the next check in 1 second
    
    def create_usage_tracker_tab(self):
        # Button to show report
        self.show_report_button = tk.Button(self.usage_tracker_tab, text="Show Report", command=self.show_report,
                                             font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat")
        self.show_report_button.pack(pady=20)

        # Button to load log file
        self.load_log_button = tk.Button(self.usage_tracker_tab, text="Load Log File", command=self.open_log_selection_window,
                                          font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat")
        self.load_log_button.pack(pady=20)

    def play_background_music(self, file):
        """Play background music."""
        try:
            pygame.mixer.music.load(file)
            pygame.mixer.music.play(-1)  # Loop indefinitely
        except pygame.error as e:
            messagebox.showerror("Error", f"Could not play music: {e}")
    
    def start_stop_timer(self):
        if self.timer_running:
            self.stop_timer()
        else:
            self.start_timer()

    def start_timer(self):
        self.timer_running = True
        self.is_break = False
        self.start_stop_button.config(text="Stop")  # Change button text to "Stop"
        self.run_timer(self.focus_time * 60)  # Start timer for focus time

    def stop_timer(self):
        self.timer_running = False
        self.start_stop_button.config(text="Start")  # Change button text back to "Start"

    def run_timer(self, remaining_seconds):
        self.timer_label.config(text=f"{remaining_seconds // 60:02}:{remaining_seconds % 60:02}.00")
        if remaining_seconds > 0:
            self.after(1000, self.run_timer, remaining_seconds - 1)  # Call itself every second
        else:
            self.play_sound()  # Play sound when time is up
            if not self.is_break:  # Check if it's a break
                self.is_break = True
                self.quote_label.config(text="Time for a break!")  # Change quote
                self.run_timer(self.break_time * 60)  # Start break timer
            else:
                self.is_break = False
                self.quote_label.config(text="Time to focus!")  # Change quote
                self.reset_timer()  # Reset the timer

    def reset_timer(self):
        self.timer_label.config(text=f"{self.focus_time:02}:00.00")

    def toggle_music(self):
        """Toggle mute/unmute music."""
        if self.music_playing:
            pygame.mixer.music.pause()  # Pause music
            self.mute_button.config(text="Unmute")  # Update button text
        else:
            pygame.mixer.music.unpause()  # Unpause music
            self.mute_button.config(text="Mute")  # Update button text
        self.music_playing = not self.music_playing  # Toggle state
    
    def toggle_customization(self):
        """Toggle between default and custom timer settings."""
        if self.default_var.get():  # If using default timings
            self.long_break_entry.config(state="disabled")  # Disable focus time input
            self.short_break_entry.config(state="disabled")  # Disable break time input
            self.focus_time = self.default_focus_time  # Reset to default focus time
            self.break_time = self.default_break_time  # Reset to default break time
            self.reset_timer()  # Reset timer display
        else:  # If using custom timings
            self.long_break_entry.config(state="normal")  # Enable focus time input
            self.short_break_entry.config(state="normal")  # Enable break time input

    def save_custom_times(self):
        """Save custom focus and break times."""
        try:
            focus_time = int(self.long_break_entry.get())  # Get custom focus time
            break_time = int(self.short_break_entry.get())  # Get custom break time
            if focus_time <= 0 or break_time <= 0:
                raise ValueError  # Raise error if values are invalid

            self.focus_time = focus_time  # Update focus time
            self.break_time = break_time  # Update break time
            messagebox.showinfo("Success", "Custom times saved successfully!")  # Success message
            self.reset_timer()  # Reset timer display
        except ValueError:
            messagebox.showerror("Error", "Please enter valid positive integers.")  # Error message

    # Usage Tracking Functions
    def show_report(self):
        """Display the usage report in a new window."""
        report_window = Toplevel(self)
        report_window.title("Usage Report")
        report_window.geometry("600x400")
        
        # Create a scrollable text area
        report_text_area = scrolledtext.ScrolledText(report_window, width=250, height=150)
        report_text_area.pack(padx=10, pady=10)

        # Write report contents to text area
        report_text_area.insert(END, "\n".join(self.tracker.new_report) if self.tracker.new_report else "No usage data available.")
        report_text_area.config(state="disabled")  # Make it read-only

    def open_log_selection_window(self):
        """Open a window to select and load a log file."""
        log_window = Toplevel(self)
        log_window.title("Select Log File")
        log_window.geometry("300x400")
        
        listbox = Listbox(log_window)  # Listbox to display log files
        listbox.pack(padx=10, pady=10, fill="both", expand=True)

        # Load available log files into listbox
        for log_file in os.listdir(LOG_DIR):
            if log_file.endswith("_usage_log.txt"):
                listbox.insert(END, log_file)

        # Button to load the selected log file
        load_button = Button(log_window, text="Load Selected Log", command=lambda: self.load_selected_log(listbox, log_window))
        load_button.pack(pady=10)

    def load_selected_log(self, listbox, window):
        """Load and display the content of the selected log file."""
        selected_file = listbox.get(listbox.curselection())
        log_file_path = os.path.join(LOG_DIR, selected_file)

    # Close the selection window
        window.destroy()

    # Open the selected log file and display its content
        with open(log_file_path, "r", encoding="utf-8") as file:
            logs = file.read()

    # Display logs in a new window
        log_window = Toplevel(self)
        log_window.title(f"Log Viewer - {selected_file}")
        log_window.geometry("600x400")

    # Add a ScrolledText widget to display logs
        text_area = scrolledtext.ScrolledText(log_window, wrap=tk.WORD, width=70, height=20, font=("Arial", 10))
        text_area.pack(padx=10, pady=10, fill="both", expand=True)  # Make the text area fill the window
        text_area.insert(tk.END, logs)
        text_area.configure(state="disabled")


    
    
class UsageTracker(threading.Thread):
    def __init__(self):
        super().__init__()
        self.running = threading.Event()  # Event to control the running state
        self.last_log_entry = ""
        self.current_window = None
        self.new_report = []  # New data entries will be stored here
        self.log_by_app = {}  # Dictionary to store logs grouped by application
        self.excluded_app = "PomoTimer"  # Exclude this app from being tracked

        # Ensure the log directory exists
        if not os.path.exists(LOG_DIR):
            os.makedirs(LOG_DIR)

        self.log_file = self.get_log_filename()  # Generate log file name

    def get_log_filename(self):
        """Generate log filename based on the current date."""
        today = datetime.now().strftime('%Y-%m-%d')
        return os.path.join(LOG_DIR, f"{today}_usage_log.txt")  # Log file path

    def run(self):
        last_window = None
        start_time = None

        with open(self.log_file, "a", encoding="utf-8") as file:
            self.running.set()  # Set the running event
            while self.running.is_set():
                active_window = self.get_active_window_title()  # Get the currently active window title
                current_time = datetime.now()

                # Exclude tracking the app itself
                if active_window != last_window and active_window != self.excluded_app:
                    if last_window is not None:
                        end_time = current_time
                        duration = end_time - start_time
                        formatted_duration = divmod(duration.total_seconds(), 60)
                        minutes = int(formatted_duration[0])
                        seconds = int(formatted_duration[1])

                        # Log entry with date
                        log_entry = (f"{end_time.strftime('%Y-%m-%d')} - {last_window} - Start: {start_time.strftime('%H:%M:%S')} | "
                                     f"End: {end_time.strftime('%H:%M:%S')} | Duration: {minutes} minutes {seconds} seconds")
                        
                        # Add to new report
                        self.new_report.append(log_entry)

                        # Group logs by app name
                        if last_window not in self.log_by_app:
                            self.log_by_app[last_window] = []
                        self.log_by_app[last_window].append(log_entry)

                        # Write to the file
                        file.write(log_entry + "\n")
                        file.flush()

                    last_window = active_window
                    start_time = current_time

                time.sleep(1)  # Shortened sleep time for better accuracy

    def get_active_window_title(self):
        """Get the title of the currently active window."""
        user32 = ctypes.WinDLL('user32')
        GetForegroundWindow = user32.GetForegroundWindow
        GetWindowTextW = user32.GetWindowTextW
        GetWindowTextLengthW = user32.GetWindowTextLengthW

        hwnd = GetForegroundWindow()
        length = GetWindowTextLengthW(hwnd)
        buffer = ctypes.create_unicode_buffer(length + 1)
        GetWindowTextW(hwnd, buffer, length + 1)
        return buffer.value

    def start_tracking(self):
        """Start tracking the active window."""
        self.current_window = self.get_active_window_title()
        self.running.set()
        self.start()  # Start the thread

    def stop_tracking(self):
        """Stop tracking the active window."""
        self.running.clear()
        self.join(timeout=5)  # Wait for the thread to finish

if __name__ == "__main__":
    app = PomodoroApp()
    app.mainloop()

# import tkinter as tk
# from tkinter import ttk
# from tkinter import messagebox
# from datetime import datetime, timedelta
# import time
# import winsound
#
# class PomodoroApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Pomodoro Timer")
#         self.geometry("600x500")
#         self.configure(bg="#fff5f5")
#
#         self.default_focus_time = 25  # in minutes
#         self.default_break_time = 5   # in minutes
#         self.focus_time = self.default_focus_time
#         self.break_time = self.default_break_time
#         self.timer_running = False
#         self.is_break = False
#         self.current_alarm_id = None
#         self.presets = {}
#         self.alarms = {}
#         self.events = {}
#
#         # Tabs
#         self.tab_control = ttk.Notebook(self)
#         self.pomodoro_tab = ttk.Frame(self.tab_control)
#         self.customize_tab = ttk.Frame(self.tab_control)
#         self.preset_tab = ttk.Frame(self.tab_control)
#         self.alarm_tab = ttk.Frame(self.tab_control)
#         self.event_tab = ttk.Frame(self.tab_control)
#         self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
#         self.tab_control.add(self.customize_tab, text='Customize')
#         self.tab_control.add(self.preset_tab, text='Preset')
#         self.tab_control.add(self.alarm_tab, text='Alarm')
#         self.tab_control.add(self.event_tab, text='Events')
#         self.tab_control.pack(expand=1, fill="both")
#
#         self.create_pomodoro_tab()
#         self.create_customize_tab()
#         self.create_preset_tab()
#         self.create_alarm_tab()
#         self.create_event_tab()
#         self.start_periodic_checks()
#
#         # Exit Button
#         self.exit_button = tk.Button(self, text="Exit", command=self.quit, font=("Arial", 10), bg="#ff6b6b", fg="white",
#                                      relief="flat", width=10)
#         self.exit_button.pack(pady=10)
#
#     def create_pomodoro_tab(self):
#         self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
#                                     bg="#fff5f5", fg="#ff6b6b")
#         self.timer_label.pack(pady=20)
#
#         self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
#                                     fg="#4a4a4a")
#         self.quote_label.pack(pady=10)
#
#         self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
#                                            font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.start_stop_button.pack(pady=20)
#         self.reset_timer()
#
#     def create_customize_tab(self):
#         self.default_var = tk.BooleanVar(value=True)
#
#         self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
#                                             variable=self.default_var, command=self.toggle_customization,
#                                             font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
#         self.default_check.pack(pady=20)
#
#         self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
#         self.custom_frame.pack()
#
#         self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
#                                          bg="#fff5f5", fg="#4a4a4a")
#         self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
#         self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
#                                           bg="#fff5f5", fg="#4a4a4a")
#         self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
#         self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
#                                      font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.save_button.pack(pady=10)
#
#     def create_preset_tab(self):
#         self.preset_frame = tk.Frame(self.preset_tab, bg="#fff5f5")
#         self.preset_frame.pack(pady=10, padx=10, fill="x")
#
#         self.task_name_label = tk.Label(self.preset_frame, text="Task Name:", font=("Arial", 12), bg="#fff5f5")
#         self.task_name_label.grid(row=0, column=0, padx=5, pady=5)
#         self.task_name_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.task_name_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.preset_focus_label = tk.Label(self.preset_frame, text="Focus Time (minutes):", font=("Arial", 12), bg="#fff5f5")
#         self.preset_focus_label.grid(row=1, column=0, padx=5, pady=5)
#         self.preset_focus_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_focus_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.preset_break_label = tk.Label(self.preset_frame, text="Break Time (minutes):", font=("Arial", 12), bg="#fff5f5")
#         self.preset_break_label.grid(row=2, column=0, padx=5, pady=5)
#         self.preset_break_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_break_entry.grid(row=2, column=1, padx=5, pady=5)
#
#         self.add_preset_button = tk.Button(self.preset_frame, text="Add Preset", command=self.add_preset,
#                                           font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
#         self.add_preset_button.grid(row=3, columnspan=2, pady=10)
#
#         self.preset_listbox = tk.Listbox(self.preset_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
#         self.preset_listbox.pack(pady=10, padx=10, fill="x")
#
#         self.preset_listbox.bind('<<ListboxSelect>>', self.on_task_select)
#
#         self.apply_preset_button = tk.Button(self.preset_tab, text="Apply Selected Preset", command=self.apply_preset,
#                                              font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
#         self.apply_preset_button.pack(pady=5)
#
#         self.delete_preset_button = tk.Button(self.preset_tab, text="Delete Selected Preset",
#                                               command=self.delete_preset,
#                                               font=("Arial", 12), bg="#f44336", fg="white", width=20)
#         self.delete_preset_button.pack(pady=5)
#
#     def on_task_select(self, event):
#         try:
#             selected_task_index = self.preset_listbox.curselection()[0]
#             self.selected_task = self.preset_listbox.get(selected_task_index)
#         except IndexError:
#             self.selected_task = None
#
#     def create_alarm_tab(self):
#         tk.Label(self.alarm_tab, text="Set Alarm", font=("Arial", 14), bg="#fff5f5").pack(pady=10)
#
#         self.alarm_frame = tk.Frame(self.alarm_tab, bg="#fff5f5")
#         self.alarm_frame.pack(pady=10)
#
#         tk.Label(self.alarm_frame, text="Alarm Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0,
#                                                                                                       padx=5, pady=5)
#         self.alarm_time_entry = tk.Entry(self.alarm_frame, font=("Arial", 12))
#         self.alarm_time_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.set_alarm_button = tk.Button(self.alarm_tab, text="Set Alarm", command=self.set_alarm,
#                                           font=("Arial", 12), bg="#4caf50", fg="white", width=15)
#         self.set_alarm_button.pack(pady=10)
#
#         # Listbox for alarms
#         self.alarm_listbox = tk.Listbox(self.alarm_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
#         self.alarm_listbox.pack(pady=10, padx=10, fill="x")
#
#         # Button to delete selected alarm
#         self.delete_alarm_button = tk.Button(self.alarm_tab, text="Delete Selected Alarm", command=self.delete_alarm,
#                                              font=("Arial", 12), bg="#f44336", fg="white", width=20)
#         self.delete_alarm_button.pack(pady=5)
#
#     def create_event_tab(self):
#         tk.Label(self.event_tab, text="Set Event", font=("Arial", 14), bg="#fff5f5").pack(pady=10)
#
#         self.event_frame = tk.Frame(self.event_tab, bg="#fff5f5")
#         self.event_frame.pack(pady=10)
#
#         tk.Label(self.event_frame, text="Event Name:", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0, padx=5,
#                                                                                               pady=5)
#         self.event_name_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_name_entry.grid(row=0, column=1, padx=5, pady=5)
#         tk.Label(self.event_frame, text="Start Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=1, column=0,
#                                                                                                       padx=5, pady=5)
#         self.event_start_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_start_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         tk.Label(self.event_frame, text="End Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=2, column=0,
#                                                                                                     padx=5, pady=5)
#         self.event_end_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_end_entry.grid(row=2, column=1, padx=5, pady=5)
#
#         self.set_event_button = tk.Button(self.event_tab, text="Set Event", command=self.set_event,
#                                           font=("Arial", 12), bg="#4caf50", fg="white", width=15)
#         self.set_event_button.pack(pady=10)
#
#         # Listbox for events
#         self.event_listbox = tk.Listbox(self.event_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
#         self.event_listbox.pack(pady=10, padx=10, fill="x")
#
#         # Button to delete selected event
#         self.delete_event_button = tk.Button(self.event_tab, text="Delete Selected Event", command=self.delete_event,
#                                              font=("Arial", 12), bg="#f44336", fg="white", width=20)
#         self.delete_event_button.pack(pady=5)
#
#     def start_stop_timer(self):
#         if not self.timer_running:
#             self.timer_running = True
#             self.start_stop_button.config(text="Stop")
#             self.run_timer(self.focus_time * 60 * 1000)  # in milliseconds
#         else:
#             self.timer_running = False
#             self.start_stop_button.config(text="Start")
#             self.after_cancel(self.current_alarm_id)
#
#     def reset_timer(self):
#         self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#         self.quote_label.config(text="Time to focus")
#
#     def run_timer(self, time_ms):
#         if time_ms <= 0:
#             self.timer_running = False
#             self.reset_timer()
#             if self.is_break:
#                 messagebox.showinfo("Break Time", "Break time is over!")
#                 winsound.Beep(1000, 1000)
#                 self.is_break = False
#                 self.start_stop_button.config(text="Start")
#             else:
#                 messagebox.showinfo("Focus Time", "Focus time is over!")
#                 winsound.Beep(1000, 1000)
#                 self.is_break = True
#                 self.focus_time, self.break_time = self.break_time, self.focus_time
#                 self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#                 self.start_stop_button.config(text="Start")
#         else:
#             mins, ms = divmod(time_ms, 60000)
#             secs, ms = divmod(ms, 1000)
#             self.timer_label.config(text=f"{mins:02}:{secs:02}.{ms // 10:02}")
#             self.current_alarm_id = self.after(10, lambda: self.run_timer(time_ms - 10))
#
#     def save_custom_times(self):
#         if self.default_var.get():
#             self.focus_time = self.default_focus_time
#             self.break_time = self.default_break_time
#         else:
#             try:
#                 self.focus_time = int(self.long_break_entry.get())
#                 self.break_time = int(self.short_break_entry.get())
#             except ValueError:
#                 messagebox.showerror("Invalid Input", "Please enter valid integer values.")
#                 return
#         self.reset_timer()
#
#     def toggle_customization(self):
#         if self.default_var.get():
#             self.long_break_entry.config(state="disabled")
#             self.short_break_entry.config(state="disabled")
#         else:
#             self.long_break_entry.config(state="normal")
#             self.short_break_entry.config(state="normal")
#
#     def add_preset(self):
#         name = self.task_name_entry.get()
#         try:
#             focus = int(self.preset_focus_entry.get())
#             break_time = int(self.preset_break_entry.get())
#         except ValueError:
#             messagebox.showerror("Invalid Input", "Please enter valid integer values.")
#             return
#
#         if name in self.presets:
#             messagebox.showerror("Preset Exists", "Preset with this name already exists.")
#             return
#
#         self.presets[name] = (focus, break_time)
#         self.preset_listbox.insert(tk.END, name)
#
#     def apply_preset(self):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task in self.presets:
#             self.focus_time, self.break_time = self.presets[selected_task]
#             self.reset_timer()
#
#     def delete_preset(self):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task in self.presets:
#             del self.presets[selected_task]
#             self.preset_listbox.delete(tk.ACTIVE)
#
#     def set_alarm(self):
#         alarm_time_str = self.alarm_time_entry.get()
#         try:
#             alarm_time = datetime.strptime(alarm_time_str, "%H:%M").time()
#         except ValueError:
#             messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
#             return
#
#         alarm_datetime = datetime.combine(datetime.today(), alarm_time)
#         if alarm_datetime < datetime.now():
#             alarm_datetime += timedelta(days=1)
#
#         self.alarms[alarm_datetime] = alarm_time
#         self.update_alarm_listbox()  # Update listbox
#
#     def set_event(self):
#         event_name = self.event_name_entry.get()
#         try:
#             start_time_str = self.event_start_entry.get()
#             end_time_str = self.event_end_entry.get()
#             start_time = datetime.strptime(start_time_str, "%H:%M").time()
#             end_time = datetime.strptime(end_time_str, "%H:%M").time()
#         except ValueError:
#             messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
#             return
#
#         start_datetime = datetime.combine(datetime.today(), start_time)
#         end_datetime = datetime.combine(datetime.today(), end_time)
#         if end_datetime < start_datetime:
#             end_datetime += timedelta(days=1)
#
#         if start_datetime < datetime.now():
#             start_datetime += timedelta(days=1)
#         if end_datetime < datetime.now():
#             end_datetime += timedelta(days=1)
#
#         self.events[event_name] = (start_datetime, end_datetime)
#         self.update_event_listbox()  # Update listbox
#
#     def update_alarm_listbox(self):
#         self.alarm_listbox.delete(0, tk.END)
#         for alarm_time in sorted(self.alarms.keys()):
#             self.alarm_listbox.insert(tk.END, alarm_time.strftime("%H:%M"))
#
#     def update_event_listbox(self):
#         self.event_listbox.delete(0, tk.END)
#         for event_name in self.events.keys():
#             start_time, end_time = self.events[event_name]
#             self.event_listbox.insert(tk.END,
#                                       f"{event_name}: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}")
#
#     def delete_alarm(self):
#         selected_alarm_index = self.alarm_listbox.curselection()
#         if selected_alarm_index:
#             selected_alarm_time_str = self.alarm_listbox.get(selected_alarm_index[0])
#             selected_alarm_time = datetime.strptime(selected_alarm_time_str, "%H:%M").time()
#             alarm_datetime = datetime.combine(datetime.today(), selected_alarm_time)
#             if alarm_datetime in self.alarms:
#                 del self.alarms[alarm_datetime]
#                 self.update_alarm_listbox()  # Update listbox
#
#     def delete_event(self):
#         selected_event_index = self.event_listbox.curselection()
#         if selected_event_index:
#             selected_event_info = self.event_listbox.get(selected_event_index[0])
#             event_name = selected_event_info.split(":")[0]
#             if event_name in self.events:
#                 del self.events[event_name]
#                 self.update_event_listbox()  # Update listbox
#
#     def check_alarms(self):
#         current_time = datetime.now()
#         alarms_to_remove = []
#         for alarm_time in sorted(self.alarms.keys()):
#             if alarm_time <= current_time:
#                 messagebox.showinfo("Alarm", "Alarm time reached!")
#                 winsound.Beep(1000, 1000)
#                 alarms_to_remove.append(alarm_time)
#         for alarm_time in alarms_to_remove:
#             del self.alarms[alarm_time]
#
#     def check_events(self):
#         current_time = datetime.now()
#         events_to_remove = []
#         for event_name, (start_datetime, end_datetime) in sorted(self.events.items()):
#             if start_datetime <= current_time <= end_datetime:
#                 messagebox.showinfo("Event", f"{event_name} is starting!")
#                 winsound.Beep(1000, 1000)
#                 events_to_remove.append(event_name)
#         for event_name in events_to_remove:
#             del self.events[event_name]
#
#     def start_periodic_checks(self):
#         self.check_alarms()
#         self.check_events()
#         self.after(1000, self.start_periodic_checks)  # Schedule the next check in 1 second
#
# if __name__ == "__main__":
#     app = PomodoroApp()
#     app.mainloop()

# import tkinter as tk
# from tkinter import ttk
# from tkinter import messagebox
# from datetime import datetime, timedelta
# import time
# import winsound
#
# class PomodoroApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Pomodoro Timer")
#         self.geometry("600x500")
#         self.configure(bg="#fff5f5")
#
#         self.default_focus_time = 25  # in minutes
#         self.default_break_time = 5   # in minutes
#         self.focus_time = self.default_focus_time
#         self.break_time = self.default_break_time
#         self.timer_running = False
#         self.is_break = False
#         self.current_alarm_id = None
#         self.presets = {}
#         self.alarms = {}
#         self.events = {}
#
#         # Tabs
#         self.tab_control = ttk.Notebook(self)
#         self.pomodoro_tab = ttk.Frame(self.tab_control)
#         self.customize_tab = ttk.Frame(self.tab_control)
#         self.preset_tab = ttk.Frame(self.tab_control)
#         self.alarm_tab = ttk.Frame(self.tab_control)
#         self.event_tab = ttk.Frame(self.tab_control)
#         self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
#         self.tab_control.add(self.customize_tab, text='Customize')
#         self.tab_control.add(self.preset_tab, text='Preset')
#         self.tab_control.add(self.alarm_tab, text='Alarm')
#         self.tab_control.add(self.event_tab, text='Events')
#         self.tab_control.pack(expand=1, fill="both")
#
#         self.create_pomodoro_tab()
#         self.create_customize_tab()
#         self.create_preset_tab()
#         self.create_alarm_tab()
#         self.create_event_tab()
#
#         # Exit Button
#         self.exit_button = tk.Button(self, text="Exit", command=self.quit, font=("Arial", 10), bg="#ff6b6b", fg="white",
#                                      relief="flat", width=10)
#         self.exit_button.pack(pady=10)
#
#     def create_pomodoro_tab(self):
#         self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
#                                     bg="#fff5f5", fg="#ff6b6b")
#         self.timer_label.pack(pady=20)
#
#         self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
#                                     fg="#4a4a4a")
#         self.quote_label.pack(pady=10)
#
#         self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
#                                            font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.start_stop_button.pack(pady=20)
#         self.reset_timer()
#
#     def create_customize_tab(self):
#         self.default_var = tk.BooleanVar(value=True)
#
#         self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
#                                             variable=self.default_var, command=self.toggle_customization,
#                                             font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
#         self.default_check.pack(pady=20)
#
#         self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
#         self.custom_frame.pack()
#
#         self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
#                                          bg="#fff5f5", fg="#4a4a4a")
#         self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
#         self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
#                                           bg="#fff5f5", fg="#4a4a4a")
#         self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
#         self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
#                                      font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.save_button.pack(pady=10)
#
#     def create_preset_tab(self):
#         self.preset_frame = tk.Frame(self.preset_tab, bg="#fff5f5")
#         self.preset_frame.pack(pady=10, padx=10, fill="x")
#
#         self.task_name_label = tk.Label(self.preset_frame, text="Task Name:", font=("Arial", 12), bg="#fff5f5")
#         self.task_name_label.grid(row=0, column=0, padx=5, pady=5)
#         self.task_name_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.task_name_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.preset_focus_label = tk.Label(self.preset_frame, text="Focus Time (minutes):", font=("Arial", 12), bg="#fff5f5")
#         self.preset_focus_label.grid(row=1, column=0, padx=5, pady=5)
#         self.preset_focus_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_focus_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.preset_break_label = tk.Label(self.preset_frame, text="Break Time (minutes):", font=("Arial", 12), bg="#fff5f5")
#         self.preset_break_label.grid(row=2, column=0, padx=5, pady=5)
#         self.preset_break_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_break_entry.grid(row=2, column=1, padx=5, pady=5)
#
#         self.add_preset_button = tk.Button(self.preset_frame, text="Add Preset", command=self.add_preset,
#                                           font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
#         self.add_preset_button.grid(row=3, columnspan=2, pady=10)
#
#         self.preset_listbox = tk.Listbox(self.preset_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
#         self.preset_listbox.pack(pady=10, padx=10, fill="x")
#
#         self.preset_listbox.bind('<<ListboxSelect>>', self.on_task_select)
#
#         self.apply_preset_button = tk.Button(self.preset_tab, text="Apply Selected Preset", command=self.apply_preset,
#                                              font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
#         self.apply_preset_button.pack(pady=5)
#
#         self.delete_preset_button = tk.Button(self.preset_tab, text="Delete Selected Preset",
#                                               command=self.delete_preset,
#                                               font=("Arial", 12), bg="#f44336", fg="white", width=20)
#         self.delete_preset_button.pack(pady=5)
#
#     def on_task_select(self, event):
#         try:
#             selected_task_index = self.preset_listbox.curselection()[0]
#             self.selected_task = self.preset_listbox.get(selected_task_index)
#         except IndexError:
#             self.selected_task = None
#
#     def create_alarm_tab(self):
#         tk.Label(self.alarm_tab, text="Set Alarm", font=("Arial", 14), bg="#fff5f5").pack(pady=10)
#
#         self.alarm_frame = tk.Frame(self.alarm_tab, bg="#fff5f5")
#         self.alarm_frame.pack(pady=10)
#
#         tk.Label(self.alarm_frame, text="Alarm Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0,
#                                                                                                       padx=5, pady=5)
#         self.alarm_time_entry = tk.Entry(self.alarm_frame, font=("Arial", 12))
#         self.alarm_time_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.set_alarm_button = tk.Button(self.alarm_tab, text="Set Alarm", command=self.set_alarm,
#                                           font=("Arial", 12), bg="#4caf50", fg="white", width=15)
#         self.set_alarm_button.pack(pady=10)
#
#         # Listbox for alarms
#         self.alarm_listbox = tk.Listbox(self.alarm_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
#         self.alarm_listbox.pack(pady=10, padx=10, fill="x")
#
#         # Button to delete selected alarm
#         self.delete_alarm_button = tk.Button(self.alarm_tab, text="Delete Selected Alarm", command=self.delete_alarm,
#                                              font=("Arial", 12), bg="#f44336", fg="white", width=20)
#         self.delete_alarm_button.pack(pady=5)
#
#     def create_event_tab(self):
#         tk.Label(self.event_tab, text="Set Event", font=("Arial", 14), bg="#fff5f5").pack(pady=10)
#
#         self.event_frame = tk.Frame(self.event_tab, bg="#fff5f5")
#         self.event_frame.pack(pady=10)
#
#         tk.Label(self.event_frame, text="Event Name:", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0, padx=5,
#                                                                                               pady=5)
#         self.event_name_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_name_entry.grid(row=0, column=1, padx=5, pady=5)
#         tk.Label(self.event_frame, text="Start Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=1, column=0,
#                                                                                                       padx=5, pady=5)
#         self.event_start_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_start_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         tk.Label(self.event_frame, text="End Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=2, column=0,
#                                                                                                     padx=5, pady=5)
#         self.event_end_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_end_entry.grid(row=2, column=1, padx=5, pady=5)
#
#         self.set_event_button = tk.Button(self.event_tab, text="Set Event", command=self.set_event,
#                                           font=("Arial", 12), bg="#4caf50", fg="white", width=15)
#         self.set_event_button.pack(pady=10)
#
#         # Listbox for events
#         self.event_listbox = tk.Listbox(self.event_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
#         self.event_listbox.pack(pady=10, padx=10, fill="x")
#
#         # Button to delete selected event
#         self.delete_event_button = tk.Button(self.event_tab, text="Delete Selected Event", command=self.delete_event,
#                                              font=("Arial", 12), bg="#f44336", fg="white", width=20)
#         self.delete_event_button.pack(pady=5)
#
#     def start_stop_timer(self):
#         if not self.timer_running:
#             self.timer_running = True
#             self.start_stop_button.config(text="Stop")
#             self.run_timer(self.focus_time * 60 * 1000)  # in milliseconds
#         else:
#             self.timer_running = False
#             self.start_stop_button.config(text="Start")
#             self.after_cancel(self.current_alarm_id)
#
#     def reset_timer(self):
#         self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#         self.quote_label.config(text="Time to focus")
#
#     def run_timer(self, time_ms):
#         if time_ms <= 0:
#             self.timer_running = False
#             self.reset_timer()
#             if self.is_break:
#                 messagebox.showinfo("Break Time", "Break time is over!")
#                 winsound.Beep(1000, 1000)
#                 self.is_break = False
#                 self.start_stop_button.config(text="Start")
#             else:
#                 messagebox.showinfo("Focus Time", "Focus time is over!")
#                 winsound.Beep(1000, 1000)
#                 self.is_break = True
#                 self.focus_time, self.break_time = self.break_time, self.focus_time
#                 self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#                 self.start_stop_button.config(text="Start")
#         else:
#             mins, ms = divmod(time_ms, 60000)
#             secs, ms = divmod(ms, 1000)
#             self.timer_label.config(text=f"{mins:02}:{secs:02}.{ms // 10:02}")
#             self.current_alarm_id = self.after(10, lambda: self.run_timer(time_ms - 10))
#
#     def save_custom_times(self):
#         if self.default_var.get():
#             self.focus_time = self.default_focus_time
#             self.break_time = self.default_break_time
#         else:
#             try:
#                 self.focus_time = int(self.long_break_entry.get())
#                 self.break_time = int(self.short_break_entry.get())
#             except ValueError:
#                 messagebox.showerror("Invalid Input", "Please enter valid integer values.")
#                 return
#         self.reset_timer()
#
#     def toggle_customization(self):
#         if self.default_var.get():
#             self.long_break_entry.config(state="disabled")
#             self.short_break_entry.config(state="disabled")
#         else:
#             self.long_break_entry.config(state="normal")
#             self.short_break_entry.config(state="normal")
#
#     def add_preset(self):
#         name = self.task_name_entry.get()
#         try:
#             focus = int(self.preset_focus_entry.get())
#             break_time = int(self.preset_break_entry.get())
#         except ValueError:
#             messagebox.showerror("Invalid Input", "Please enter valid integer values.")
#             return
#
#         if name in self.presets:
#             messagebox.showerror("Preset Exists", "Preset with this name already exists.")
#             return
#
#         self.presets[name] = (focus, break_time)
#         self.preset_listbox.insert(tk.END, name)
#
#     def apply_preset(self):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task in self.presets:
#             self.focus_time, self.break_time = self.presets[selected_task]
#             self.reset_timer()
#
#     def delete_preset(self):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task in self.presets:
#             del self.presets[selected_task]
#             self.preset_listbox.delete(tk.ACTIVE)
#
#     def set_alarm(self):
#         alarm_time_str = self.alarm_time_entry.get()
#         try:
#             alarm_time = datetime.strptime(alarm_time_str, "%H:%M").time()
#         except ValueError:
#             messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
#             return
#
#         alarm_datetime = datetime.combine(datetime.today(), alarm_time)
#         if alarm_datetime < datetime.now():
#             alarm_datetime += timedelta(days=1)
#
#         self.alarms[alarm_datetime] = alarm_time
#         self.update_alarm_listbox()  # Update listbox
#
#     def set_event(self):
#         event_name = self.event_name_entry.get()
#         try:
#             start_time_str = self.event_start_entry.get()
#             end_time_str = self.event_end_entry.get()
#             start_time = datetime.strptime(start_time_str, "%H:%M").time()
#             end_time = datetime.strptime(end_time_str, "%H:%M").time()
#         except ValueError:
#             messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
#             return
#
#         start_datetime = datetime.combine(datetime.today(), start_time)
#         end_datetime = datetime.combine(datetime.today(), end_time)
#         if end_datetime < start_datetime:
#             end_datetime += timedelta(days=1)
#
#         if start_datetime < datetime.now():
#             start_datetime += timedelta(days=1)
#         if end_datetime < datetime.now():
#             end_datetime += timedelta(days=1)
#
#         self.events[event_name] = (start_datetime, end_datetime)
#         self.update_event_listbox()  # Update listbox
#
#     def update_alarm_listbox(self):
#         self.alarm_listbox.delete(0, tk.END)
#         for alarm_time in sorted(self.alarms.keys()):
#             self.alarm_listbox.insert(tk.END, alarm_time.strftime("%H:%M"))
#
#     def update_event_listbox(self):
#         self.event_listbox.delete(0, tk.END)
#         for event_name in self.events.keys():
#             start_time, end_time = self.events[event_name]
#             self.event_listbox.insert(tk.END,
#                                       f"{event_name}: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}")
#
#     def delete_alarm(self):
#         selected_alarm_index = self.alarm_listbox.curselection()
#         if selected_alarm_index:
#             selected_alarm_time_str = self.alarm_listbox.get(selected_alarm_index[0])
#             selected_alarm_time = datetime.strptime(selected_alarm_time_str, "%H:%M").time()
#             alarm_datetime = datetime.combine(datetime.today(), selected_alarm_time)
#             if alarm_datetime in self.alarms:
#                 del self.alarms[alarm_datetime]
#                 self.update_alarm_listbox()  # Update listbox
#
#     def delete_event(self):
#         selected_event_index = self.event_listbox.curselection()
#         if selected_event_index:
#             selected_event_info = self.event_listbox.get(selected_event_index[0])
#             event_name = selected_event_info.split(":")[0]
#             if event_name in self.events:
#                 del self.events[event_name]
#                 self.update_event_listbox()  # Update listbox
#
#     def check_alarms(self):
#         current_time = datetime.now()
#         for alarm_time in sorted(self.alarms.keys()):
#             if alarm_time <= current_time:
#                 messagebox.showinfo("Alarm", "Alarm time reached!")
#                 winsound.Beep(1000, 1000)
#                 del self.alarms[alarm_time]
#             else:
#                 self.after(1000, self.check_alarms)
#                 return  # Exit the loop once the next check is scheduled
#
#     def check_events(self):
#         current_time = datetime.now()
#         for event_name, (start_datetime, end_datetime) in sorted(self.events.items()):
#             if start_datetime <= current_time <= end_datetime:
#                 messagebox.showinfo("Event", f"{event_name} is starting!")
#                 winsound.Beep(1000, 1000)
#                 del self.events[event_name]
#             else:
#                 self.after(1000, self.check_events)
#                 return  # Exit the loop once the next check is scheduled
#
# if __name__ == "__main__":
#     app = PomodoroApp()
#     app.mainloop()

# import tkinter as tk
# from tkinter import ttk
# from tkinter import messagebox
# from datetime import datetime, timedelta
# import time
# import winsound
#
# class PomodoroApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Pomodoro Timer")
#         self.geometry("600x500")
#         self.configure(bg="#fff5f5")
#
#         self.default_focus_time = 25  # in minutes
#         self.default_break_time = 5   # in minutes
#         self.focus_time = self.default_focus_time
#         self.break_time = self.default_break_time
#         self.timer_running = False
#         self.is_break = False
#         self.current_alarm_id = None
#         self.presets = {}
#         self.alarms = {}
#         self.events = {}
#
#         # Tabs
#         self.tab_control = ttk.Notebook(self)
#         self.pomodoro_tab = ttk.Frame(self.tab_control)
#         self.customize_tab = ttk.Frame(self.tab_control)
#         self.preset_tab = ttk.Frame(self.tab_control)
#         self.alarm_tab = ttk.Frame(self.tab_control)
#         self.event_tab = ttk.Frame(self.tab_control)
#         self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
#         self.tab_control.add(self.customize_tab, text='Customize')
#         self.tab_control.add(self.preset_tab, text='Preset')
#         self.tab_control.add(self.alarm_tab, text='Alarm')
#         self.tab_control.add(self.event_tab, text='Events')
#         self.tab_control.pack(expand=1, fill="both")
#
#         self.create_pomodoro_tab()
#         self.create_customize_tab()
#         self.create_preset_tab()
#         self.create_alarm_tab()
#         self.create_event_tab()
#
#         # Exit Button
#         self.exit_button = tk.Button(self, text="Exit", command=self.quit, font=("Arial", 10), bg="#ff6b6b", fg="white",
#                                      relief="flat", width=10)
#         self.exit_button.pack(pady=10)
#
#     def create_pomodoro_tab(self):
#         self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
#                                     bg="#fff5f5", fg="#ff6b6b")
#         self.timer_label.pack(pady=20)
#
#         self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
#                                     fg="#4a4a4a")
#         self.quote_label.pack(pady=10)
#
#         self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
#                                            font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.start_stop_button.pack(pady=20)
#         self.reset_timer()
#
#     def create_customize_tab(self):
#         self.default_var = tk.BooleanVar(value=True)
#
#         self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
#                                             variable=self.default_var, command=self.toggle_customization,
#                                             font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
#         self.default_check.pack(pady=20)
#
#         self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
#         self.custom_frame.pack()
#
#         self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
#                                          bg="#fff5f5", fg="#4a4a4a")
#         self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
#         self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
#                                           bg="#fff5f5", fg="#4a4a4a")
#         self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
#         self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
#                                      font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.save_button.pack(pady=10)
#
#     def create_preset_tab(self):
#         self.preset_frame = tk.Frame(self.preset_tab, bg="#fff5f5")
#         self.preset_frame.pack(pady=10, padx=10, fill="x")
#
#         self.task_name_label = tk.Label(self.preset_frame, text="Task Name:", font=("Arial", 12), bg="#fff5f5")
#         self.task_name_label.grid(row=0, column=0, padx=5, pady=5)
#         self.task_name_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.task_name_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.preset_focus_label = tk.Label(self.preset_frame, text="Focus Time (minutes):", font=("Arial", 12), bg="#fff5f5")
#         self.preset_focus_label.grid(row=1, column=0, padx=5, pady=5)
#         self.preset_focus_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_focus_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.preset_break_label = tk.Label(self.preset_frame, text="Break Time (minutes):", font=("Arial", 12), bg="#fff5f5")
#         self.preset_break_label.grid(row=2, column=0, padx=5, pady=5)
#         self.preset_break_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_break_entry.grid(row=2, column=1, padx=5, pady=5)
#
#         self.add_preset_button = tk.Button(self.preset_frame, text="Add Preset", command=self.add_preset,
#                                           font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
#         self.add_preset_button.grid(row=3, columnspan=2, pady=10)
#
#         self.preset_listbox = tk.Listbox(self.preset_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
#         self.preset_listbox.pack(pady=10, padx=10, fill="x")
#
#         self.preset_listbox.bind('<<ListboxSelect>>', self.on_task_select)
#
#         self.apply_preset_button = tk.Button(self.preset_tab, text="Apply Selected Preset", command=self.apply_preset,
#                                              font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
#         self.apply_preset_button.pack(pady=5)
#
#         self.delete_preset_button = tk.Button(self.preset_tab, text="Delete Selected Preset",
#                                               command=self.delete_preset,
#                                               font=("Arial", 12), bg="#f44336", fg="white", width=20)
#         self.delete_preset_button.pack(pady=5)
#
#     def on_task_select(self, event):
#         try:
#             selected_task_index = self.preset_listbox.curselection()[0]
#             self.selected_task = self.preset_listbox.get(selected_task_index)
#         except IndexError:
#             self.selected_task = None
#
#     def create_alarm_tab(self):
#         tk.Label(self.alarm_tab, text="Set Alarm", font=("Arial", 14), bg="#fff5f5").pack(pady=10)
#
#         self.alarm_frame = tk.Frame(self.alarm_tab, bg="#fff5f5")
#         self.alarm_frame.pack(pady=10)
#
#         tk.Label(self.alarm_frame, text="Alarm Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0, padx=5, pady=5)
#         self.alarm_time_entry = tk.Entry(self.alarm_frame, font=("Arial", 12))
#         self.alarm_time_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.set_alarm_button = tk.Button(self.alarm_tab, text="Set Alarm", command=self.set_alarm,
#                                           font=("Arial", 12), bg="#4caf50", fg="white", width=15)
#         self.set_alarm_button.pack(pady=10)
#
#     def create_event_tab(self):
#         tk.Label(self.event_tab, text="Set Event", font=("Arial", 14), bg="#fff5f5").pack(pady=10)
#
#         self.event_frame = tk.Frame(self.event_tab, bg="#fff5f5")
#         self.event_frame.pack(pady=10)
#
#         tk.Label(self.event_frame, text="Event Name:", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0, padx=5, pady=5)
#         self.event_name_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_name_entry.grid(row=0,column=1, padx=5, pady=5)
#         tk.Label(self.event_frame, text="Start Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=1, column=0,
#                                                                                                       padx=5, pady=5)
#         self.event_start_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_start_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         tk.Label(self.event_frame, text="End Time (HH:MM):", font=("Arial", 12), bg="#fff5f5").grid(row=2, column=0,
#                                                                                                     padx=5, pady=5)
#         self.event_end_entry = tk.Entry(self.event_frame, font=("Arial", 12))
#         self.event_end_entry.grid(row=2, column=1, padx=5, pady=5)
#
#         self.set_event_button = tk.Button(self.event_tab, text="Set Event", command=self.set_event,
#                                           font=("Arial", 12), bg="#4caf50", fg="white", width=15)
#         self.set_event_button.pack(pady=10)
#
#     def start_stop_timer(self):
#         if not self.timer_running:
#             self.timer_running = True
#             self.start_stop_button.config(text="Stop")
#             self.run_timer(self.focus_time * 60 * 1000)  # in milliseconds
#         else:
#             self.timer_running = False
#             self.start_stop_button.config(text="Start")
#             self.after_cancel(self.current_alarm_id)
#
#     def reset_timer(self):
#         self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#         self.quote_label.config(text="Time to focus")
#
#     def run_timer(self, time_ms):
#         if time_ms <= 0:
#             self.timer_running = False
#             self.reset_timer()
#             if self.is_break:
#                 messagebox.showinfo("Break Time", "Break time is over!")
#                 winsound.Beep(1000, 1000)
#                 self.is_break = False
#                 self.start_stop_button.config(text="Start")
#             else:
#                 messagebox.showinfo("Focus Time", "Focus time is over!")
#                 winsound.Beep(1000, 1000)
#                 self.is_break = True
#                 self.focus_time, self.break_time = self.break_time, self.focus_time
#                 self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#                 self.start_stop_button.config(text="Start")
#         else:
#             mins, ms = divmod(time_ms, 60000)
#             secs, ms = divmod(ms, 1000)
#             self.timer_label.config(text=f"{mins:02}:{secs:02}.{ms // 10:02}")
#             self.current_alarm_id = self.after(10, lambda: self.run_timer(time_ms - 10))
#
#     def save_custom_times(self):
#         if self.default_var.get():
#             self.focus_time = self.default_focus_time
#             self.break_time = self.default_break_time
#         else:
#             try:
#                 self.focus_time = int(self.long_break_entry.get())
#                 self.break_time = int(self.short_break_entry.get())
#             except ValueError:
#                 messagebox.showerror("Invalid Input", "Please enter valid integer values.")
#                 return
#         self.reset_timer()
#
#     def toggle_customization(self):
#         if self.default_var.get():
#             self.long_break_entry.config(state="disabled")
#             self.short_break_entry.config(state="disabled")
#         else:
#             self.long_break_entry.config(state="normal")
#             self.short_break_entry.config(state="normal")
#
#     def add_preset(self):
#         name = self.task_name_entry.get()
#         try:
#             focus = int(self.preset_focus_entry.get())
#             break_time = int(self.preset_break_entry.get())
#         except ValueError:
#             messagebox.showerror("Invalid Input", "Please enter valid integer values.")
#             return
#
#         if name in self.presets:
#             messagebox.showerror("Preset Exists", "Preset with this name already exists.")
#             return
#
#         self.presets[name] = (focus, break_time)
#         self.preset_listbox.insert(tk.END, name)
#
#     def apply_preset(self):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task in self.presets:
#             self.focus_time, self.break_time = self.presets[selected_task]
#             self.reset_timer()
#
#     def delete_preset(self):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task in self.presets:
#             del self.presets[selected_task]
#             self.preset_listbox.delete(tk.ACTIVE)
#
#     def set_alarm(self):
#         alarm_time_str = self.alarm_time_entry.get()
#         try:
#             alarm_time = datetime.strptime(alarm_time_str, "%H:%M").time()
#         except ValueError:
#             messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
#             return
#
#         alarm_datetime = datetime.combine(datetime.today(), alarm_time)
#         if alarm_datetime < datetime.now():
#             alarm_datetime += timedelta(days=1)
#
#         self.alarms[alarm_datetime] = alarm_time
#         self.check_alarms()
#
#     def set_event(self):
#         event_name = self.event_name_entry.get()
#         try:
#             start_time_str = self.event_start_entry.get()
#             end_time_str = self.event_end_entry.get()
#             start_time = datetime.strptime(start_time_str, "%H:%M").time()
#             end_time = datetime.strptime(end_time_str, "%H:%M").time()
#         except ValueError:
#             messagebox.showerror("Invalid Time", "Please enter time in HH:MM format.")
#             return
#
#         start_datetime = datetime.combine(datetime.today(), start_time)
#         end_datetime = datetime.combine(datetime.today(), end_time)
#         if end_datetime < start_datetime:
#             end_datetime += timedelta(days=1)
#
#         if start_datetime < datetime.now():
#             start_datetime += timedelta(days=1)
#         if end_datetime < datetime.now():
#             end_datetime += timedelta(days=1)
#
#         self.events[event_name] = (start_datetime, end_datetime)
#         self.check_events()
#
#     def check_alarms(self):
#         current_time = datetime.now()
#         for alarm_time in sorted(self.alarms.keys()):
#             if alarm_time <= current_time:
#                 messagebox.showinfo("Alarm", "Alarm time reached!")
#                 winsound.Beep(1000, 1000)
#                 del self.alarms[alarm_time]
#             else:
#                 self.after(1000, self.check_alarms)
#
#     def check_events(self):
#         current_time = datetime.now()
#         for event_name, (start_datetime, end_datetime) in sorted(self.events.items()):
#             if start_datetime <= current_time <= end_datetime:
#                 messagebox.showinfo("Event", f"{event_name} is starting!")
#                 winsound.Beep(1000, 1000)
#                 del self.events[event_name]
#             else:
#                 self.after(1000, self.check_events)
#
# if __name__ == "__main__":
#     app = PomodoroApp()
#     app.mainloop()

# from tkinter import ttk, messagebox
# import tkinter as tk
#
# class PomodoroApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Pomodoro Timer")
#         self.geometry("500x450")
#         self.configure(bg="#fff5f5")
#
#         self.default_focus_time = 25  # in minutes
#         self.default_break_time = 5   # in minutes
#         self.focus_time = self.default_focus_time
#         self.break_time = self.default_break_time
#         self.timer_running = False
#         self.is_break = False
#         self.current_alarm_id = None
#         self.presets = {}
#         self.alarms = {}
#         self.events = {}
#
#         # Tabs
#         self.tab_control = ttk.Notebook(self)
#         self.pomodoro_tab = ttk.Frame(self.tab_control)
#         self.customize_tab = ttk.Frame(self.tab_control)
#         self.preset_tab = ttk.Frame(self.tab_control)
#         self.alarm_tab = ttk.Frame(self.tab_control)
#         self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
#         self.tab_control.add(self.customize_tab, text='Customize')
#         self.tab_control.add(self.preset_tab, text='Preset')
#         self.tab_control.add(self.alarm_tab, text='Alarm')
#         self.tab_control.pack(expand=1, fill="both")
#
#         self.create_pomodoro_tab()
#         self.create_customize_tab()
#         self.create_preset_tab()
#         self.create_alarm_tab()
#         self.create_view_alarms_tab()
#
#         # Exit Button
#         self.exit_button = tk.Button(self, text="Exit", command=self.quit, font=("Arial", 10), bg="#ff6b6b", fg="white",
#                                      relief="flat", width=10)
#         self.exit_button.pack(pady=10)
#
#     def create_pomodoro_tab(self):
#         self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
#                                     bg="#fff5f5", fg="#ff6b6b")
#         self.timer_label.pack(pady=20)
#
#         self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
#                                     fg="#4a4a4a")
#         self.quote_label.pack(pady=10)
#
#         self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
#                                            font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.start_stop_button.pack(pady=20)
#         self.reset_timer()
#
#     def create_customize_tab(self):
#         self.default_var = tk.BooleanVar(value=True)
#
#         self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
#                                             variable=self.default_var, command=self.toggle_customization,
#                                             font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
#         self.default_check.pack(pady=20)
#
#         self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
#         self.custom_frame.pack()
#
#         self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
#                                          bg="#fff5f5", fg="#4a4a4a")
#         self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
#         self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
#                                           bg="#fff5f5", fg="#4a4a4a")
#         self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
#         self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
#                                      font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.save_button.pack(pady=10)
#
#     def create_preset_tab(self):
#         # Create UI elements for preset tasks
#         self.preset_listbox = tk.Listbox(self.preset_tab, font=("Arial", 12), height=10, selectmode=tk.SINGLE)
#         self.preset_listbox.pack(pady=10, padx=10, fill="x")
#
#         # Create entry fields for adding new presets
#         self.task_name_label = tk.Label(self.preset_tab, text="Task Name:", font=("Arial", 12))
#         self.task_name_label.pack(pady=5)
#
#         self.task_name_entry = tk.Entry(self.preset_tab, font=("Arial", 12))
#         self.task_name_entry.pack(pady=5)
#
#         self.focus_time_label = tk.Label(self.preset_tab, text="Focus Time (minutes):", font=("Arial", 12))
#         self.focus_time_label.pack(pady=5)
#
#         self.focus_time_entry = tk.Entry(self.preset_tab, font=("Arial", 12))
#         self.focus_time_entry.pack(pady=5)
#
#         self.break_time_label = tk.Label(self.preset_tab, text="Break Time (minutes):", font=("Arial", 12))
#         self.break_time_label.pack(pady=5)
#
#         self.break_time_entry = tk.Entry(self.preset_tab, font=("Arial", 12))
#         self.break_time_entry.pack(pady=5)
#
#         self.add_preset_button = tk.Button(self.preset_tab, text="Add Preset", command=self.add_preset,
#                                            font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
#         self.add_preset_button.pack(pady=5)
#
#         # Add existing buttons for applying or deleting presets
#         self.apply_preset_button = tk.Button(self.preset_tab, text="Apply Selected Preset", command=self.apply_preset,
#                                              font=("Arial", 12), bg="#4CAF50", fg="white", width=20)
#         self.apply_preset_button.pack(pady=5)
#
#         self.delete_preset_button = tk.Button(self.preset_tab, text="Delete Selected Preset",
#                                               command=self.delete_preset,
#                                               font=("Arial", 12), bg="#f44336", fg="white", width=20)
#         self.delete_preset_button.pack(pady=5)
#
#     def add_preset(self):
#         task_name = self.task_name_entry.get()
#         try:
#             focus_time = int(self.focus_time_entry.get())
#             break_time = int(self.break_time_entry.get())
#             if task_name in self.presets:
#                 messagebox.showwarning("Preset Exists", "Preset with this name already exists.")
#                 return
#             self.preset_listbox.insert(tk.END, task_name)
#             self.presets[task_name] = (focus_time, break_time)
#             self.task_name_entry.delete(0, tk.END)
#             self.focus_time_entry.delete(0, tk.END)
#             self.break_time_entry.delete(0, tk.END)
#         except ValueError:
#             messagebox.showerror("Invalid Input", "Please enter valid numbers for times.")
#
#     def apply_preset(self):
#         try:
#             selected_index = self.preset_listbox.curselection()[0]
#             task_name = self.preset_listbox.get(selected_index)
#             self.focus_time, self.break_time = self.presets[task_name]
#             self.reset_timer()
#         except IndexError:
#             messagebox.showwarning("Selection Error", "Please select a task to apply.")
#         except KeyError:
#             messagebox.showerror("Preset Error", "Preset not found.")
#
#     def delete_preset(self):
#         try:
#             selected_index = self.preset_listbox.curselection()[0]
#             task_name = self.preset_listbox.get(selected_index)
#             if messagebox.askyesno("Confirm Delete", f"Are you sure you want to delete the preset '{task_name}'?"):
#                 del self.presets[task_name]
#                 self.preset_listbox.delete(selected_index)
#         except IndexError:
#             messagebox.showwarning("Selection Error", "Please select a task to delete.")
#
#     def on_task_select(self, event):
#         selected = self.preset_listbox.curselection()
#         if selected:
#             self.preset_listbox.selection_set(selected)
#             self.preset_name_entry.delete(0, tk.END)
#             self.preset_focus_entry.delete(0, tk.END)
#             self.preset_break_entry.delete(0, tk.END)
#             task_name = self.preset_listbox.get(selected[0])
#             self.preset_name_entry.insert(0, task_name)
#             if task_name in self.presets:
#                 focus_time, break_time = self.presets[task_name]
#                 self.preset_focus_entry.insert(0, focus_time)
#                 self.preset_break_entry.insert(0, break_time)
#
#     def create_alarm_tab(self):
#         self.alarm_label = tk.Label(self.alarm_tab, text="Alarm Tab (Placeholder)", font=("Arial", 12), bg="#fff5f5")
#         self.alarm_label.pack(pady=10)
#
#     def create_view_alarms_tab(self):
#         self.view_alarms_label = tk.Label(self.alarm_tab, text="View Alarms Tab (Placeholder)", font=("Arial", 12), bg="#fff5f5")
#         self.view_alarms_label.pack(pady=10)
#
#     def start_stop_timer(self):
#         if not self.timer_running:
#             self.timer_running = True
#             self.start_stop_button.config(text="Stop")
#             self.run_timer()
#         else:
#             self.timer_running = False
#             self.start_stop_button.config(text="Start")
#             self.after_cancel(self.current_alarm_id)
#
#     def reset_timer(self):
#         if self.timer_running:
#             self.after_cancel(self.current_alarm_id)
#             self.timer_running = False
#             self.start_stop_button.config(text="Start")
#         self.update_timer_label(self.focus_time * 60 * 1000)
#
#     def update_timer_label(self, time_ms):
#         minutes, remainder = divmod(time_ms, 60 * 1000)
#         seconds, milliseconds = divmod(remainder, 1000)
#         self.timer_label.config(text=f"{minutes:02}:{seconds:02}.{milliseconds // 10:02}")
#
#     def run_timer(self, time_ms=None):
#         if time_ms is None:
#             if self.is_break:
#                 time_ms = self.break_time * 60 * 1000
#                 self.quote_label.config(text="Break Time")
#             else:
#                 time_ms = self.focus_time * 60 * 1000
#                 self.quote_label.config(text="Focus Time")
#
#         self.update_timer_label(time_ms)
#         if time_ms <= 0:
#             self.is_break = not self.is_break
#             self.run_timer()
#         else:
#             self.current_alarm_id = self.after(10, lambda: self.run_timer(time_ms - 10))
#
#     def toggle_customization(self):
#         if self.default_var.get():
#             self.long_break_entry.config(state="disabled")
#             self.short_break_entry.config(state="disabled")
#             self.focus_time = self.default_focus_time
#             self.break_time = self.default_break_time
#         else:
#             self.long_break_entry.config(state="normal")
#             self.short_break_entry.config(state="normal")
#
#     def save_custom_times(self):
#         if not self.default_var.get():
#             try:
#                 focus_time = int(self.long_break_entry.get())
#                 break_time = int(self.short_break_entry.get())
#                 if focus_time > 0 and break_time >= 0:
#                     self.focus_time = focus_time
#                     self.break_time = break_time
#                     self.reset_timer()
#                 else:
#                     messagebox.showerror("Invalid Input", "Focus time must be greater than 0 and break time should be non-negative.")
#             except ValueError:
#                 messagebox.showerror("Invalid Input", "Please enter valid numbers for times.")
#
# if __name__ == "__main__":
#     app = PomodoroApp()
#     app.mainloop()


# import tkinter as tk
# from tkinter import ttk
# from tkinter import messagebox
#
# class PomodoroApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Pomodoro Timer")
#         self.geometry("400x400")
#         self.configure(bg="#fff5f5")
#
#         self.default_focus_time = 25  # in minutes
#         self.default_break_time = 5   # in minutes
#         self.focus_time = self.default_focus_time
#         self.break_time = self.default_break_time
#         self.timer_running = False
#         self.is_break = False
#
#         # Store presets as a dictionary: {task_name: (focus_time, break_time)}
#         self.presets = {}
#
#         # Tabs
#         self.tab_control = ttk.Notebook(self)
#         self.pomodoro_tab = ttk.Frame(self.tab_control)
#         self.customize_tab = ttk.Frame(self.tab_control)
#         self.preset_tab = ttk.Frame(self.tab_control)
#         self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
#         self.tab_control.add(self.customize_tab, text='Customize')
#         self.tab_control.add(self.preset_tab, text='Preset')
#         self.tab_control.pack(expand=1, fill="both")
#
#         self.create_pomodoro_tab()
#         self.create_customize_tab()
#         self.create_preset_tab()
#
#         # Exit Button
#         self.exit_button = tk.Button(self, text="Exit", command=self.quit, font=("Arial", 10), bg="#ff6b6b", fg="white",
#                                      relief="flat", width=10)
#         self.exit_button.pack(pady=10)
#
#     def create_pomodoro_tab(self):
#         self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.000", font=("Arial", 24),
#                                     bg="#fff5f5", fg="#ff6b6b")
#         self.timer_label.pack(pady=20)
#
#         self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
#                                     fg="#4a4a4a")
#         self.quote_label.pack(pady=10)
#
#         self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
#                                            font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.start_stop_button.pack(pady=20)
#         self.reset_timer()
#
#     def create_customize_tab(self):
#         self.default_var = tk.BooleanVar(value=True)
#
#         self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
#                                             variable=self.default_var, command=self.toggle_customization,
#                                             font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
#         self.default_check.pack(pady=20)
#
#         self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
#         self.custom_frame.pack()
#
#         self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
#                                          bg="#fff5f5", fg="#4a4a4a")
#         self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
#         self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
#                                           bg="#fff5f5", fg="#4a4a4a")
#         self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
#         self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
#                                      font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.save_button.pack(pady=10)
#
#     def create_preset_tab(self):
#         self.preset_listbox = tk.Listbox(self.preset_tab, font=("Arial", 12), height=5)
#         self.preset_listbox.pack(pady=10, padx=10, fill="x")
#
#         self.preset_listbox.bind('<<ListboxSelect>>', self.display_selected_preset)
#
#         self.preset_frame = tk.Frame(self.preset_tab, bg="#fff5f5")
#         self.preset_frame.pack(pady=10)
#
#         tk.Label(self.preset_frame, text="Task Name:", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0, padx=5, pady=5)
#         self.task_name_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.task_name_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         tk.Label(self.preset_frame, text="Focus Time (minutes):", font=("Arial", 12), bg="#fff5f5").grid(row=1, column=0, padx=5, pady=5)
#         self.preset_focus_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_focus_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         tk.Label(self.preset_frame, text="Break Time (minutes):", font=("Arial", 12), bg="#fff5f5").grid(row=2, column=0, padx=5, pady=5)
#         self.preset_break_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_break_entry.grid(row=2, column=1, padx=5, pady=5)
#
#         # Buttons for Add, Delete, and Save
#         self.add_preset_button = tk.Button(self.preset_tab, text="Add Task", command=self.add_preset,
#                                            font=("Arial", 12), bg="#4caf50", fg="white", width=10)
#         self.add_preset_button.pack(pady=5)
#
#         self.delete_preset_button = tk.Button(self.preset_tab, text="Delete Task", command=self.confirm_delete_preset,
#                                               font=("Arial", 12), bg="#f44336", fg="white", width=10)
#         self.delete_preset_button.pack(pady=5)
#
#         self.save_preset_button = tk.Button(self.preset_tab, text="Apply Preset", command=self.apply_preset,
#                                             font=("Arial", 12), bg="#ff6b6b", fg="white", width=10)
#         self.save_preset_button.pack(pady=5)
#
#     def toggle_customization(self):
#         if self.default_var.get():
#             self.long_break_entry.config(state="disabled")
#             self.short_break_entry.config(state="disabled")
#         else:
#             self.long_break_entry.config(state="normal")
#             self.short_break_entry.config(state="normal")
#
#     def save_custom_times(self):
#         if not self.default_var.get():
#             try:
#                 focus_time = int(self.long_break_entry.get())
#                 break_time = int(self.short_break_entry.get())
#
#                 if focus_time == 0 and break_time == 0:
#                     messagebox.showwarning("Invalid Input", "Either Focus Time or Break Time must be greater than 0.")
#                     return
#
#                 if focus_time >= 0 and break_time >= 0:
#                     self.focus_time = focus_time
#                     self.break_time = break_time
#                     self.reset_timer()
#                 else:
#                     messagebox.showwarning("Invalid Input", "Please enter non-negative integer values for the times.")
#             except ValueError:
#                 messagebox.showwarning("Invalid Input", "Please enter valid integer values for the times.")
#         else:
#             self.focus_time = self.default_focus_time
#             self.break_time = self.default_break_time
#             self.reset_timer()
#
#     def reset_timer(self):
#         self.timer_label.config(text=f"{self.focus_time:02}:00.000")
#         self.quote_label.config(text="Time to focus")
#         self.timer_running = False
#         self.is_break = False
#         self.start_stop_button.config(text="Start")
#
#     def start_stop_timer(self):
#         if not self.timer_running:
#             self.timer_running = True
#             self.start_stop_button.config(text="Stop")
#             self.run_timer(self.focus_time * 60 * 1000 if not self.is_break else self.break_time * 60 * 1000)
#         else:
#             self.timer_running = False
#             self.reset_timer()
#
#     def run_timer(self, countdown_time):
#         if self.timer_running:
#             if countdown_time <= 0:
#                 self.is_break = not self.is_break
#                 self.quote_label.config(text="Time to rest" if self.is_break else "Time to focus")
#                 self.run_timer(self.break_time * 60 * 1000 if self.is_break else self.focus_time * 60 * 1000)
#                 return
#
#             minutes, milliseconds = divmod(int(countdown_time), 60000)
#             seconds, milliseconds = divmod(milliseconds, 1000)
#             self.timer_label.config(text=f"{minutes:02}:{seconds:02}.{milliseconds:03}")
#             self.after(10, self.run_timer, countdown_time - 10)
#
#     def display_selected_preset(self, event):
#         if len(self.preset_listbox.curselection()) > 0:
#             selected_index = self.preset_listbox.curselection()[0]
#             selected_task = self.preset_listbox.get(selected_index)
#             task_focus, task_break = self.presets[selected_task]
#
#             self.task_name_entry.config(state="normal")
#             self.preset_focus_entry.config(state="normal")
#             self.preset_break_entry.config(state="normal")
#
#             self.task_name_entry.delete(0, tk.END)
#             self.task_name_entry.insert(0, selected_task)
#             self.preset_focus_entry.delete(0, tk.END)
#             self.preset_focus_entry.insert(0, task_focus)
#             self.preset_break_entry.delete(0, tk.END)
#             self.preset_break_entry.insert(0, task_break)
#
#             self.task_name_entry.config(state="disabled")
#             self.preset_focus_entry.config(state="disabled")
#             self.preset_break_entry.config(state="disabled")
#
#     def add_preset(self):
#         task_name = self.task_name_entry.get()
#         try:
#             task_focus = int(self.preset_focus_entry.get())
#             task_break = int(self.preset_break_entry.get())
#             if task_name and task_focus >= 0 and task_break >= 0:
#                 self.presets[task_name] = (task_focus, task_break)
#                 self.preset_listbox.insert(tk.END, task_name)
#                 self.task_name_entry.delete(0, tk.END)
#                 self.preset_focus_entry.delete(0, tk.END)
#                 self.preset_break_entry.delete(0, tk.END)
#             else:
#                 messagebox.showwarning("Invalid Input", "Ensure task name and valid times are entered.")
#         except ValueError:
#             messagebox.showwarning("Invalid Input", "Enter valid numeric values for focus and break times.")
#
#     def confirm_delete_preset(self):
#         selected_index = self.preset_listbox.curselection()
#         if selected_index:
#             selected_task = self.preset_listbox.get(selected_index)
#             confirm = messagebox.askyesno("Confirm Deletion", f"Are you sure you want to delete {selected_task}?")
#             if confirm:
#                 self.preset_listbox.delete(selected_index)
#                 del self.presets[selected_task]
#                 self.task_name_entry.config(state="normal")
#                 self.preset_focus_entry.config(state="normal")
#                 self.preset_break_entry.config(state="normal")
#                 self.task_name_entry.delete(0, tk.END)
#                 self.preset_focus_entry.delete(0, tk.END)
#                 self.preset_break_entry.delete(0, tk.END)
#
#     def apply_preset(self):
#         selected_index = self.preset_listbox.curselection()
#         if selected_index:
#             selected_task = self.preset_listbox.get(selected_index)
#             task_focus, task_break = self.presets[selected_task]
#             self.focus_time = task_focus
#             self.break_time = task_break
#             self.reset_timer()
#
# if __name__ == "__main__":
#     app = PomodoroApp()
#     app.mainloop()

# import tkinter as tk
# from tkinter import ttk
# from tkinter import messagebox
#
# class PomodoroApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Pomodoro Timer")
#         self.geometry("400x400")
#         self.configure(bg="#fff5f5")
#
#         self.default_focus_time = 25  # in minutes
#         self.default_break_time = 5   # in minutes
#         self.focus_time = self.default_focus_time
#         self.break_time = self.default_break_time
#         self.timer_running = False
#         self.is_break = False
#
#         # Store presets as a dictionary: {task_name: (focus_time, break_time)}
#         self.presets = {}
#
#         # Tabs
#         self.tab_control = ttk.Notebook(self)
#         self.pomodoro_tab = ttk.Frame(self.tab_control)
#         self.customize_tab = ttk.Frame(self.tab_control)
#         self.preset_tab = ttk.Frame(self.tab_control)
#         self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
#         self.tab_control.add(self.customize_tab, text='Customize')
#         self.tab_control.add(self.preset_tab, text='Preset')
#         self.tab_control.pack(expand=1, fill="both")
#
#         self.create_pomodoro_tab()
#         self.create_customize_tab()
#         self.create_preset_tab()
#
#         # Exit Button
#         self.exit_button = tk.Button(self, text="Exit", command=self.quit, font=("Arial", 10), bg="#ff6b6b", fg="white",
#                                      relief="flat", width=10)
#         self.exit_button.pack(pady=10)
#
#     def create_pomodoro_tab(self):
#         self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
#                                     bg="#fff5f5", fg="#ff6b6b")
#         self.timer_label.pack(pady=20)
#
#         self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
#                                     fg="#4a4a4a")
#         self.quote_label.pack(pady=10)
#
#         self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
#                                            font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.start_stop_button.pack(pady=20)
#         self.reset_timer()
#
#     def create_customize_tab(self):
#         self.default_var = tk.BooleanVar(value=True)
#
#         self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
#                                             variable=self.default_var, command=self.toggle_customization,
#                                             font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
#         self.default_check.pack(pady=20)
#
#         self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
#         self.custom_frame.pack()
#
#         self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
#                                          bg="#fff5f5", fg="#4a4a4a")
#         self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
#         self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
#                                           bg="#fff5f5", fg="#4a4a4a")
#         self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
#         self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
#                                      font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.save_button.pack(pady=10)
#
#     def create_preset_tab(self):
#         self.preset_listbox = tk.Listbox(self.preset_tab, font=("Arial", 12), height=5)
#         self.preset_listbox.pack(pady=10, padx=10, fill="x")
#
#         self.preset_listbox.bind('<<ListboxSelect>>', self.display_selected_preset)
#
#         self.preset_frame = tk.Frame(self.preset_tab, bg="#fff5f5")
#         self.preset_frame.pack(pady=10)
#
#         tk.Label(self.preset_frame, text="Task Name:", font=("Arial", 12), bg="#fff5f5").grid(row=0, column=0, padx=5, pady=5)
#         self.task_name_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.task_name_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         tk.Label(self.preset_frame, text="Focus Time (minutes):", font=("Arial", 12), bg="#fff5f5").grid(row=1, column=0, padx=5, pady=5)
#         self.preset_focus_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_focus_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         tk.Label(self.preset_frame, text="Break Time (minutes):", font=("Arial", 12), bg="#fff5f5").grid(row=2, column=0, padx=5, pady=5)
#         self.preset_break_entry = tk.Entry(self.preset_frame, font=("Arial", 12))
#         self.preset_break_entry.grid(row=2, column=1, padx=5, pady=5)
#
#         # Buttons for Add, Delete, and Save
#         self.add_preset_button = tk.Button(self.preset_tab, text="Add Task", command=self.add_preset,
#                                            font=("Arial", 12), bg="#4caf50", fg="white", width=10)
#         self.add_preset_button.pack(pady=5)
#
#         self.delete_preset_button = tk.Button(self.preset_tab, text="Delete Task", command=self.delete_preset,
#                                               font=("Arial", 12), bg="#f44336", fg="white", width=10)
#         self.delete_preset_button.pack(pady=5)
#
#         self.save_preset_button = tk.Button(self.preset_tab, text="Apply Preset", command=self.apply_preset,
#                                             font=("Arial", 12), bg="#ff6b6b", fg="white", width=10)
#         self.save_preset_button.pack(pady=5)
#
#     def toggle_customization(self):
#         if self.default_var.get():
#             self.long_break_entry.config(state="disabled")
#             self.short_break_entry.config(state="disabled")
#         else:
#             self.long_break_entry.config(state="normal")
#             self.short_break_entry.config(state="normal")
#
#     def save_custom_times(self):
#         if not self.default_var.get():
#             try:
#                 focus_time = int(self.long_break_entry.get())
#                 break_time = int(self.short_break_entry.get())
#
#                 # Allow 0 for either focus_time or break_time, but not both.
#                 if focus_time == 0 and break_time == 0:
#                     messagebox.showwarning("Invalid Input", "Either Focus Time or Break Time must be greater than 0.")
#                     return
#
#                 if focus_time >= 0 and break_time >= 0:
#                     self.focus_time = focus_time
#                     self.break_time = break_time
#                     self.reset_timer()
#                 else:
#                     messagebox.showwarning("Invalid Input", "Please enter non-negative integer values for the times.")
#             except ValueError:
#                 messagebox.showwarning("Invalid Input", "Please enter valid integer values for the times.")
#         else:
#             self.focus_time = self.default_focus_time
#             self.break_time = self.default_break_time
#             self.reset_timer()
#
#     def reset_timer(self):
#         self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#         self.quote_label.config(text="Time to focus")
#         self.timer_running = False
#         self.is_break = False
#         self.start_stop_button.config(text="Start")
#
#     def start_stop_timer(self):
#         if not self.timer_running:
#             self.timer_running = True
#             self.start_stop_button.config(text="Stop")
#             self.run_timer(self.focus_time * 60 if not self.is_break else self.break_time * 60)
#         else:
#             self.timer_running = False
#             self.reset_timer()
#
#     def run_timer(self, countdown_time):
#         if self.timer_running:
#             if countdown_time <= 0:
#                 # Skip to the next phase if the countdown time is 0
#                 self.is_break = not self.is_break
#                 self.quote_label.config(text="Time to rest" if self.is_break else "Time to focus")
#                 self.run_timer(self.break_time * 60 if self.is_break else self.focus_time * 60)
#                 return
#
#             minutes, seconds = divmod(int(countdown_time), 60)
#             self.timer_label.config(text=f"{minutes:02}:{seconds:02}")
#             self.after(1000, self.run_timer, countdown_time - 1)
#
#     def add_preset(self):
#         task_name = self.task_name_entry.get().strip()
#         if task_name == "" or task_name in self.presets:
#             messagebox.showwarning("Invalid Task", "Task name cannot be empty or a duplicate.")
#             return
#
#         try:
#             focus_time = int(self.preset_focus_entry.get())
#             break_time = int(self.preset_break_entry.get())
#         except ValueError:
#             messagebox.showwarning("Invalid Input", "Please enter valid integer values for the times.")
#             return
#
#         self.presets[task_name] = (focus_time, break_time)
#         self.preset_listbox.insert(tk.END, task_name)
#
#         # Clear the input fields
#         self.task_name_entry.delete(0, tk.END)
#         self.preset_focus_entry.delete(0, tk.END)
#         self.preset_break_entry.delete(0, tk.END)
#
#     def delete_preset(self):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task:
#             del self.presets[selected_task]
#             self.preset_listbox.delete(tk.ACTIVE)
#
#     def apply_preset(self):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task:
#             focus_time, break_time = self.presets[selected_task]
#             self.focus_time = focus_time
#             self.break_time = break_time
#             self.reset_timer()
#             messagebox.showinfo("Preset Applied", f"Preset '{selected_task}' applied with {focus_time}m focus time and {break_time}m break time.")
#
#     def display_selected_preset(self, event):
#         selected_task = self.preset_listbox.get(tk.ACTIVE)
#         if selected_task:
#             focus_time, break_time = self.presets[selected_task]
#             self.preset_focus_entry.delete(0, tk.END)
#             self.preset_break_entry.delete(0, tk.END)
#             self.preset_focus_entry.insert(tk.END, str(focus_time))
#             self.preset_break_entry.insert(tk.END, str(break_time))
#
# if __name__ == "__main__":
#     app = PomodoroApp()
#     app.mainloop()

# import tkinter as tk
# from tkinter import ttk
# from tkinter import messagebox
#
# class PomodoroApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Pomodoro Timer")
#         self.geometry("400x300")
#         self.configure(bg="#fff5f5")
#
#         self.default_focus_time = 25  # in minutes
#         self.default_break_time = 5   # in minutes
#         self.focus_time = self.default_focus_time
#         self.break_time = self.default_break_time
#         self.timer_running = False
#         self.is_break = False
#
#         # Tabs
#         self.tab_control = ttk.Notebook(self)
#         self.pomodoro_tab = ttk.Frame(self.tab_control)
#         self.customize_tab = ttk.Frame(self.tab_control)
#         self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
#         self.tab_control.add(self.customize_tab, text='Customize')
#         self.tab_control.pack(expand=1, fill="both")
#
#         self.create_pomodoro_tab()
#         self.create_customize_tab()
#
#         # Exit Button
#         self.exit_button = tk.Button(self, text="Exit", command=self.quit, font=("Arial", 10), bg="#ff6b6b", fg="white",
#                                      relief="flat", width=10)
#         self.exit_button.pack(pady=10)
#
#     def create_pomodoro_tab(self):
#         self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
#                                     bg="#fff5f5", fg="#ff6b6b")
#         self.timer_label.pack(pady=20)
#
#         self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
#                                     fg="#4a4a4a")
#         self.quote_label.pack(pady=10)
#
#         self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
#                                            font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.start_stop_button.pack(pady=20)
#         self.reset_timer()
#
#     def create_customize_tab(self):
#         self.default_var = tk.BooleanVar(value=True)
#
#         self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
#                                             variable=self.default_var, command=self.toggle_customization,
#                                             font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
#         self.default_check.pack(pady=20)
#
#         self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
#         self.custom_frame.pack()
#
#         self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
#                                          bg="#fff5f5", fg="#4a4a4a")
#         self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
#         self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
#                                           bg="#fff5f5", fg="#4a4a4a")
#         self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
#         self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
#                                      font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.save_button.pack(pady=10)
#
#     def toggle_customization(self):
#         if self.default_var.get():
#             self.long_break_entry.config(state="disabled")
#             self.short_break_entry.config(state="disabled")
#         else:
#             self.long_break_entry.config(state="normal")
#             self.short_break_entry.config(state="normal")
#
#     def save_custom_times(self):
#         if not self.default_var.get():
#             try:
#                 focus_time = int(self.long_break_entry.get())
#                 break_time = int(self.short_break_entry.get())
#
#                 # Allow 0 for either focus_time or break_time, but not both.
#                 if focus_time == 0 and break_time == 0:
#                     messagebox.showwarning("Invalid Input", "Either Focus Time or Break Time must be greater than 0.")
#                     return
#
#                 if focus_time >= 0 and break_time >= 0:
#                     self.focus_time = focus_time
#                     self.break_time = break_time
#                     self.reset_timer()
#                 else:
#                     messagebox.showwarning("Invalid Input", "Please enter non-negative integer values for the times.")
#             except ValueError:
#                 messagebox.showwarning("Invalid Input", "Please enter valid integer values for the times.")
#         else:
#             self.focus_time = self.default_focus_time
#             self.break_time = self.default_break_time
#             self.reset_timer()
#
#     def reset_timer(self):
#         self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#         self.quote_label.config(text="Time to focus")
#         self.timer_running = False
#         self.is_break = False
#         self.start_stop_button.config(text="Start")
#
#     def start_stop_timer(self):
#         if not self.timer_running:
#             self.timer_running = True
#             self.start_stop_button.config(text="Stop")
#             self.run_timer(self.focus_time * 60 if not self.is_break else self.break_time * 60)
#         else:
#             self.timer_running = False
#             self.reset_timer()
#
#     def run_timer(self, countdown_time):
#         if self.timer_running:
#             if countdown_time <= 0:
#                 # Skip to the next phase if the countdown time is 0
#                 self.is_break = not self.is_break
#                 self.quote_label.config(text="Time to rest" if self.is_break else "Time to focus")
#                 self.run_timer(self.break_time * 60 if self.is_break else self.focus_time * 60)
#                 return
#
#             minutes, seconds = divmod(int(countdown_time), 60)
#             milliseconds = int((countdown_time * 100) % 100)
#             self.timer_label.config(text=f"{minutes:02}:{seconds:02}.{milliseconds:02}")
#             if countdown_time > 0:
#                 self.after(10, self.run_timer, countdown_time - 0.01)
#             else:
#                 self.is_break = not self.is_break
#                 self.quote_label.config(text="Time to rest" if self.is_break else "Time to focus")
#                 self.run_timer(self.break_time * 60 if self.is_break else self.focus_time * 60)
#
# if __name__ == "__main__":
#     app = PomodoroApp()
#     app.mainloop()


# import tkinter as tk
# from tkinter import ttk
# from tkinter import messagebox
#
# class PomodoroApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Pomodoro Timer")
#         self.geometry("400x300")
#         self.configure(bg="#fff5f5")
#
#         self.default_focus_time = 25  # in minutes
#         self.default_break_time = 5   # in minutes
#         self.focus_time = self.default_focus_time
#         self.break_time = self.default_break_time
#         self.timer_running = False
#         self.is_break = False
#
#         # Tabs
#         self.tab_control = ttk.Notebook(self)
#         self.pomodoro_tab = ttk.Frame(self.tab_control)
#         self.customize_tab = ttk.Frame(self.tab_control)
#         self.tab_control.add(self.pomodoro_tab, text='Pomodoro')
#         self.tab_control.add(self.customize_tab, text='Customize')
#         self.tab_control.pack(expand=1, fill="both")
#
#         self.create_pomodoro_tab()
#         self.create_customize_tab()
#
#         # Exit Button
#         self.exit_button = tk.Button(self, text="Exit", command=self.quit, font=("Arial", 10), bg="#ff6b6b", fg="white",
#                                      relief="flat", width=10)
#         self.exit_button.pack(pady=10)
#
#     def create_pomodoro_tab(self):
#         self.timer_label = tk.Label(self.pomodoro_tab, text=f"{self.focus_time:02}:00.00", font=("Arial", 24),
#                                     bg="#fff5f5", fg="#ff6b6b")
#         self.timer_label.pack(pady=20)
#
#         self.quote_label = tk.Label(self.pomodoro_tab, text="Time to focus", font=("Arial", 16), bg="#fff5f5",
#                                     fg="#4a4a4a")
#         self.quote_label.pack(pady=10)
#
#         self.start_stop_button = tk.Button(self.pomodoro_tab, text="Start", command=self.start_stop_timer,
#                                            font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.start_stop_button.pack(pady=20)
#         self.reset_timer()
#
#     def create_customize_tab(self):
#         self.default_var = tk.BooleanVar(value=True)
#
#         self.default_check = tk.Checkbutton(self.customize_tab, text="Default 25m/5m Pomodoro",
#                                             variable=self.default_var, command=self.toggle_customization,
#                                             font=("Arial", 12), bg="#fff5f5", fg="#4a4a4a")
#         self.default_check.pack(pady=20)
#
#         self.custom_frame = tk.Frame(self.customize_tab, bg="#fff5f5")
#         self.custom_frame.pack()
#
#         self.long_break_label = tk.Label(self.custom_frame, text="Focus Time (minutes):", font=("Arial", 12),
#                                          bg="#fff5f5", fg="#4a4a4a")
#         self.long_break_label.grid(row=0, column=0, padx=5, pady=5)
#         self.long_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.long_break_entry.grid(row=0, column=1, padx=5, pady=5)
#
#         self.short_break_label = tk.Label(self.custom_frame, text="Break Time (minutes):", font=("Arial", 12),
#                                           bg="#fff5f5", fg="#4a4a4a")
#         self.short_break_label.grid(row=1, column=0, padx=5, pady=5)
#         self.short_break_entry = tk.Entry(self.custom_frame, state="disabled", font=("Arial", 12))
#         self.short_break_entry.grid(row=1, column=1, padx=5, pady=5)
#
#         self.save_button = tk.Button(self.customize_tab, text="Save", command=self.save_custom_times,
#                                      font=("Arial", 12), bg="#ff6b6b", fg="white", relief="flat", width=10)
#         self.save_button.pack(pady=10)
#
#     def toggle_customization(self):
#         if self.default_var.get():
#             self.long_break_entry.config(state="disabled")
#             self.short_break_entry.config(state="disabled")
#         else:
#             self.long_break_entry.config(state="normal")
#             self.short_break_entry.config(state="normal")
#
#     def save_custom_times(self):
#         if not self.default_var.get():
#             try:
#                 focus_time = int(self.long_break_entry.get())
#                 break_time = int(self.short_break_entry.get())
#                 if focus_time > 0 and break_time > 0:
#                     self.focus_time = focus_time
#                     self.break_time = break_time
#                     self.reset_timer()
#                 else:
#                     messagebox.showwarning("Invalid Input", "Please enter positive integer values for the times.")
#             except ValueError:
#                 messagebox.showwarning("Invalid Input", "Please enter valid integer values for the times.")
#         else:
#             self.focus_time = self.default_focus_time
#             self.break_time = self.default_break_time
#             self.reset_timer()
#
#     def reset_timer(self):
#         self.timer_label.config(text=f"{self.focus_time:02}:00.00")
#         self.quote_label.config(text="Time to focus")
#         self.timer_running = False
#         self.is_break = False
#         self.start_stop_button.config(text="Start")
#
#     def start_stop_timer(self):
#         if not self.timer_running:
#             self.timer_running = True
#             self.start_stop_button.config(text="Stop")
#             self.run_timer(self.focus_time * 60 if not self.is_break else self.break_time * 60)
#         else:
#             self.timer_running = False
#             self.reset_timer()
#
#     def run_timer(self, countdown_time):
#         if self.timer_running:
#             minutes, seconds = divmod(int(countdown_time), 60)
#             milliseconds = int((countdown_time * 100) % 100)
#             # Ensure the display is always in MM:SS.mm format
#             self.timer_label.config(text=f"{minutes:02}:{seconds:02}.{milliseconds:02}")
#             if countdown_time > 0:
#                 self.after(10, self.run_timer, countdown_time - 0.01)
#             else:
#                 self.is_break = not self.is_break
#                 self.quote_label.config(text="Time to rest" if self.is_break else "Time to focus")
#                 self.run_timer(self.break_time * 60 if self.is_break else self.focus_time * 60)
#
# if __name__ == "__main__":
#     app = PomodoroApp()
#     app.mainloop()

